// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"skrshop/internal/data/ent/accountplatform"
	"skrshop/internal/data/ent/accountuser"
	"skrshop/internal/data/ent/authitem"
	"skrshop/internal/data/ent/authms"
	"skrshop/internal/data/ent/authmsmenu"
	"skrshop/internal/data/ent/authrole"
	"skrshop/internal/data/ent/authrolestaff"
	"skrshop/internal/data/ent/predicate"
	"skrshop/internal/data/ent/productattr"
	"skrshop/internal/data/ent/productattrvalue"
	"skrshop/internal/data/ent/productbrands"
	"skrshop/internal/data/ent/productcategory"
	"skrshop/internal/data/ent/productsku"
	"skrshop/internal/data/ent/productskustock"
	"skrshop/internal/data/ent/productspu"
	"skrshop/internal/data/ent/productspuskuattrmap"
	"skrshop/internal/data/ent/skrmember"
	"skrshop/internal/data/ent/staffinfo"
	"sync"
	"time"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccountPlatform      = "AccountPlatform"
	TypeAccountUser          = "AccountUser"
	TypeAuthItem             = "AuthItem"
	TypeAuthMs               = "AuthMs"
	TypeAuthMsMenu           = "AuthMsMenu"
	TypeAuthRole             = "AuthRole"
	TypeAuthRoleStaff        = "AuthRoleStaff"
	TypeProductAttr          = "ProductAttr"
	TypeProductAttrValue     = "ProductAttrValue"
	TypeProductBrands        = "ProductBrands"
	TypeProductCategory      = "ProductCategory"
	TypeProductSku           = "ProductSku"
	TypeProductSkuStock      = "ProductSkuStock"
	TypeProductSpu           = "ProductSpu"
	TypeProductSpuSkuAttrMap = "ProductSpuSkuAttrMap"
	TypeSkrMember            = "SkrMember"
	TypeStaffInfo            = "StaffInfo"
)

// AccountPlatformMutation represents an operation that mutates the AccountPlatform nodes in the graph.
type AccountPlatformMutation struct {
	config
	op             Op
	typ            string
	id             *int
	uid            *int64
	adduid         *int64
	platform_id    *string
	platform_token *string
	nickname       *string
	avatar         *string
	_type          *int8
	add_type       *int8
	create_at      *time.Time
	update_at      *time.Time
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*AccountPlatform, error)
	predicates     []predicate.AccountPlatform
}

var _ ent.Mutation = (*AccountPlatformMutation)(nil)

// accountplatformOption allows management of the mutation configuration using functional options.
type accountplatformOption func(*AccountPlatformMutation)

// newAccountPlatformMutation creates new mutation for the AccountPlatform entity.
func newAccountPlatformMutation(c config, op Op, opts ...accountplatformOption) *AccountPlatformMutation {
	m := &AccountPlatformMutation{
		config:        c,
		op:            op,
		typ:           TypeAccountPlatform,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountPlatformID sets the ID field of the mutation.
func withAccountPlatformID(id int) accountplatformOption {
	return func(m *AccountPlatformMutation) {
		var (
			err   error
			once  sync.Once
			value *AccountPlatform
		)
		m.oldValue = func(ctx context.Context) (*AccountPlatform, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AccountPlatform.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccountPlatform sets the old AccountPlatform of the mutation.
func withAccountPlatform(node *AccountPlatform) accountplatformOption {
	return func(m *AccountPlatformMutation) {
		m.oldValue = func(context.Context) (*AccountPlatform, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountPlatformMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountPlatformMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *AccountPlatformMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUID sets the "uid" field.
func (m *AccountPlatformMutation) SetUID(i int64) {
	m.uid = &i
	m.adduid = nil
}

// UID returns the value of the "uid" field in the mutation.
func (m *AccountPlatformMutation) UID() (r int64, exists bool) {
	v := m.uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUID returns the old "uid" field's value of the AccountPlatform entity.
// If the AccountPlatform object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountPlatformMutation) OldUID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUID: %w", err)
	}
	return oldValue.UID, nil
}

// AddUID adds i to the "uid" field.
func (m *AccountPlatformMutation) AddUID(i int64) {
	if m.adduid != nil {
		*m.adduid += i
	} else {
		m.adduid = &i
	}
}

// AddedUID returns the value that was added to the "uid" field in this mutation.
func (m *AccountPlatformMutation) AddedUID() (r int64, exists bool) {
	v := m.adduid
	if v == nil {
		return
	}
	return *v, true
}

// ResetUID resets all changes to the "uid" field.
func (m *AccountPlatformMutation) ResetUID() {
	m.uid = nil
	m.adduid = nil
}

// SetPlatformID sets the "platform_id" field.
func (m *AccountPlatformMutation) SetPlatformID(s string) {
	m.platform_id = &s
}

// PlatformID returns the value of the "platform_id" field in the mutation.
func (m *AccountPlatformMutation) PlatformID() (r string, exists bool) {
	v := m.platform_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatformID returns the old "platform_id" field's value of the AccountPlatform entity.
// If the AccountPlatform object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountPlatformMutation) OldPlatformID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPlatformID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPlatformID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatformID: %w", err)
	}
	return oldValue.PlatformID, nil
}

// ResetPlatformID resets all changes to the "platform_id" field.
func (m *AccountPlatformMutation) ResetPlatformID() {
	m.platform_id = nil
}

// SetPlatformToken sets the "platform_token" field.
func (m *AccountPlatformMutation) SetPlatformToken(s string) {
	m.platform_token = &s
}

// PlatformToken returns the value of the "platform_token" field in the mutation.
func (m *AccountPlatformMutation) PlatformToken() (r string, exists bool) {
	v := m.platform_token
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatformToken returns the old "platform_token" field's value of the AccountPlatform entity.
// If the AccountPlatform object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountPlatformMutation) OldPlatformToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPlatformToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPlatformToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatformToken: %w", err)
	}
	return oldValue.PlatformToken, nil
}

// ResetPlatformToken resets all changes to the "platform_token" field.
func (m *AccountPlatformMutation) ResetPlatformToken() {
	m.platform_token = nil
}

// SetNickname sets the "nickname" field.
func (m *AccountPlatformMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *AccountPlatformMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the AccountPlatform entity.
// If the AccountPlatform object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountPlatformMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ResetNickname resets all changes to the "nickname" field.
func (m *AccountPlatformMutation) ResetNickname() {
	m.nickname = nil
}

// SetAvatar sets the "avatar" field.
func (m *AccountPlatformMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *AccountPlatformMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the AccountPlatform entity.
// If the AccountPlatform object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountPlatformMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *AccountPlatformMutation) ResetAvatar() {
	m.avatar = nil
}

// SetType sets the "type" field.
func (m *AccountPlatformMutation) SetType(i int8) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *AccountPlatformMutation) GetType() (r int8, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the AccountPlatform entity.
// If the AccountPlatform object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountPlatformMutation) OldType(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *AccountPlatformMutation) AddType(i int8) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *AccountPlatformMutation) AddedType() (r int8, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *AccountPlatformMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetCreateAt sets the "create_at" field.
func (m *AccountPlatformMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *AccountPlatformMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the AccountPlatform entity.
// If the AccountPlatform object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountPlatformMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *AccountPlatformMutation) ResetCreateAt() {
	m.create_at = nil
}

// SetUpdateAt sets the "update_at" field.
func (m *AccountPlatformMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *AccountPlatformMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the AccountPlatform entity.
// If the AccountPlatform object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountPlatformMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *AccountPlatformMutation) ResetUpdateAt() {
	m.update_at = nil
}

// Op returns the operation name.
func (m *AccountPlatformMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AccountPlatform).
func (m *AccountPlatformMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountPlatformMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.uid != nil {
		fields = append(fields, accountplatform.FieldUID)
	}
	if m.platform_id != nil {
		fields = append(fields, accountplatform.FieldPlatformID)
	}
	if m.platform_token != nil {
		fields = append(fields, accountplatform.FieldPlatformToken)
	}
	if m.nickname != nil {
		fields = append(fields, accountplatform.FieldNickname)
	}
	if m.avatar != nil {
		fields = append(fields, accountplatform.FieldAvatar)
	}
	if m._type != nil {
		fields = append(fields, accountplatform.FieldType)
	}
	if m.create_at != nil {
		fields = append(fields, accountplatform.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, accountplatform.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountPlatformMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case accountplatform.FieldUID:
		return m.UID()
	case accountplatform.FieldPlatformID:
		return m.PlatformID()
	case accountplatform.FieldPlatformToken:
		return m.PlatformToken()
	case accountplatform.FieldNickname:
		return m.Nickname()
	case accountplatform.FieldAvatar:
		return m.Avatar()
	case accountplatform.FieldType:
		return m.GetType()
	case accountplatform.FieldCreateAt:
		return m.CreateAt()
	case accountplatform.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountPlatformMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case accountplatform.FieldUID:
		return m.OldUID(ctx)
	case accountplatform.FieldPlatformID:
		return m.OldPlatformID(ctx)
	case accountplatform.FieldPlatformToken:
		return m.OldPlatformToken(ctx)
	case accountplatform.FieldNickname:
		return m.OldNickname(ctx)
	case accountplatform.FieldAvatar:
		return m.OldAvatar(ctx)
	case accountplatform.FieldType:
		return m.OldType(ctx)
	case accountplatform.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case accountplatform.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown AccountPlatform field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountPlatformMutation) SetField(name string, value ent.Value) error {
	switch name {
	case accountplatform.FieldUID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	case accountplatform.FieldPlatformID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatformID(v)
		return nil
	case accountplatform.FieldPlatformToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatformToken(v)
		return nil
	case accountplatform.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case accountplatform.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case accountplatform.FieldType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case accountplatform.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case accountplatform.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown AccountPlatform field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountPlatformMutation) AddedFields() []string {
	var fields []string
	if m.adduid != nil {
		fields = append(fields, accountplatform.FieldUID)
	}
	if m.add_type != nil {
		fields = append(fields, accountplatform.FieldType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountPlatformMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case accountplatform.FieldUID:
		return m.AddedUID()
	case accountplatform.FieldType:
		return m.AddedType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountPlatformMutation) AddField(name string, value ent.Value) error {
	switch name {
	case accountplatform.FieldUID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUID(v)
		return nil
	case accountplatform.FieldType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	}
	return fmt.Errorf("unknown AccountPlatform numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountPlatformMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountPlatformMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountPlatformMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AccountPlatform nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountPlatformMutation) ResetField(name string) error {
	switch name {
	case accountplatform.FieldUID:
		m.ResetUID()
		return nil
	case accountplatform.FieldPlatformID:
		m.ResetPlatformID()
		return nil
	case accountplatform.FieldPlatformToken:
		m.ResetPlatformToken()
		return nil
	case accountplatform.FieldNickname:
		m.ResetNickname()
		return nil
	case accountplatform.FieldAvatar:
		m.ResetAvatar()
		return nil
	case accountplatform.FieldType:
		m.ResetType()
		return nil
	case accountplatform.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case accountplatform.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown AccountPlatform field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountPlatformMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountPlatformMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountPlatformMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountPlatformMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountPlatformMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountPlatformMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountPlatformMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AccountPlatform unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountPlatformMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AccountPlatform edge %s", name)
}

// AccountUserMutation represents an operation that mutates the AccountUser nodes in the graph.
type AccountUserMutation struct {
	config
	op            Op
	typ           string
	id            *int
	email         *string
	phone         *string
	password      *string
	create_at     *time.Time
	status        *int8
	addstatus     *int8
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AccountUser, error)
	predicates    []predicate.AccountUser
}

var _ ent.Mutation = (*AccountUserMutation)(nil)

// accountuserOption allows management of the mutation configuration using functional options.
type accountuserOption func(*AccountUserMutation)

// newAccountUserMutation creates new mutation for the AccountUser entity.
func newAccountUserMutation(c config, op Op, opts ...accountuserOption) *AccountUserMutation {
	m := &AccountUserMutation{
		config:        c,
		op:            op,
		typ:           TypeAccountUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountUserID sets the ID field of the mutation.
func withAccountUserID(id int) accountuserOption {
	return func(m *AccountUserMutation) {
		var (
			err   error
			once  sync.Once
			value *AccountUser
		)
		m.oldValue = func(ctx context.Context) (*AccountUser, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AccountUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccountUser sets the old AccountUser of the mutation.
func withAccountUser(node *AccountUser) accountuserOption {
	return func(m *AccountUserMutation) {
		m.oldValue = func(context.Context) (*AccountUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *AccountUserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetEmail sets the "email" field.
func (m *AccountUserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *AccountUserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the AccountUser entity.
// If the AccountUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountUserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *AccountUserMutation) ResetEmail() {
	m.email = nil
}

// SetPhone sets the "phone" field.
func (m *AccountUserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *AccountUserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the AccountUser entity.
// If the AccountUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountUserMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *AccountUserMutation) ResetPhone() {
	m.phone = nil
}

// SetPassword sets the "password" field.
func (m *AccountUserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *AccountUserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the AccountUser entity.
// If the AccountUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountUserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *AccountUserMutation) ResetPassword() {
	m.password = nil
}

// SetCreateAt sets the "create_at" field.
func (m *AccountUserMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *AccountUserMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the AccountUser entity.
// If the AccountUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountUserMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *AccountUserMutation) ResetCreateAt() {
	m.create_at = nil
}

// SetStatus sets the "status" field.
func (m *AccountUserMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AccountUserMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AccountUser entity.
// If the AccountUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountUserMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AccountUserMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AccountUserMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *AccountUserMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// Op returns the operation name.
func (m *AccountUserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AccountUser).
func (m *AccountUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountUserMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.email != nil {
		fields = append(fields, accountuser.FieldEmail)
	}
	if m.phone != nil {
		fields = append(fields, accountuser.FieldPhone)
	}
	if m.password != nil {
		fields = append(fields, accountuser.FieldPassword)
	}
	if m.create_at != nil {
		fields = append(fields, accountuser.FieldCreateAt)
	}
	if m.status != nil {
		fields = append(fields, accountuser.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case accountuser.FieldEmail:
		return m.Email()
	case accountuser.FieldPhone:
		return m.Phone()
	case accountuser.FieldPassword:
		return m.Password()
	case accountuser.FieldCreateAt:
		return m.CreateAt()
	case accountuser.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case accountuser.FieldEmail:
		return m.OldEmail(ctx)
	case accountuser.FieldPhone:
		return m.OldPhone(ctx)
	case accountuser.FieldPassword:
		return m.OldPassword(ctx)
	case accountuser.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case accountuser.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown AccountUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case accountuser.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case accountuser.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case accountuser.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case accountuser.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case accountuser.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown AccountUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountUserMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, accountuser.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountUserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case accountuser.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case accountuser.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown AccountUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountUserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountUserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AccountUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountUserMutation) ResetField(name string) error {
	switch name {
	case accountuser.FieldEmail:
		m.ResetEmail()
		return nil
	case accountuser.FieldPhone:
		m.ResetPhone()
		return nil
	case accountuser.FieldPassword:
		m.ResetPassword()
		return nil
	case accountuser.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case accountuser.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown AccountUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountUserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountUserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountUserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AccountUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountUserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AccountUser edge %s", name)
}

// AuthItemMutation represents an operation that mutates the AuthItem nodes in the graph.
type AuthItemMutation struct {
	config
	op            Op
	typ           string
	id            *int
	status        *int8
	addstatus     *int8
	create_at     *time.Time
	update_at     *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AuthItem, error)
	predicates    []predicate.AuthItem
}

var _ ent.Mutation = (*AuthItemMutation)(nil)

// authitemOption allows management of the mutation configuration using functional options.
type authitemOption func(*AuthItemMutation)

// newAuthItemMutation creates new mutation for the AuthItem entity.
func newAuthItemMutation(c config, op Op, opts ...authitemOption) *AuthItemMutation {
	m := &AuthItemMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthItemID sets the ID field of the mutation.
func withAuthItemID(id int) authitemOption {
	return func(m *AuthItemMutation) {
		var (
			err   error
			once  sync.Once
			value *AuthItem
		)
		m.oldValue = func(ctx context.Context) (*AuthItem, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuthItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthItem sets the old AuthItem of the mutation.
func withAuthItem(node *AuthItem) authitemOption {
	return func(m *AuthItemMutation) {
		m.oldValue = func(context.Context) (*AuthItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *AuthItemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetStatus sets the "status" field.
func (m *AuthItemMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AuthItemMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AuthItem entity.
// If the AuthItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthItemMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AuthItemMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AuthItemMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *AuthItemMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetCreateAt sets the "create_at" field.
func (m *AuthItemMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *AuthItemMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the AuthItem entity.
// If the AuthItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthItemMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *AuthItemMutation) ResetCreateAt() {
	m.create_at = nil
}

// SetUpdateAt sets the "update_at" field.
func (m *AuthItemMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *AuthItemMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the AuthItem entity.
// If the AuthItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthItemMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *AuthItemMutation) ResetUpdateAt() {
	m.update_at = nil
}

// Op returns the operation name.
func (m *AuthItemMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AuthItem).
func (m *AuthItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthItemMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.status != nil {
		fields = append(fields, authitem.FieldStatus)
	}
	if m.create_at != nil {
		fields = append(fields, authitem.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, authitem.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case authitem.FieldStatus:
		return m.Status()
	case authitem.FieldCreateAt:
		return m.CreateAt()
	case authitem.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case authitem.FieldStatus:
		return m.OldStatus(ctx)
	case authitem.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case authitem.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown AuthItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case authitem.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case authitem.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case authitem.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown AuthItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthItemMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, authitem.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case authitem.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case authitem.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown AuthItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthItemMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthItemMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AuthItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthItemMutation) ResetField(name string) error {
	switch name {
	case authitem.FieldStatus:
		m.ResetStatus()
		return nil
	case authitem.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case authitem.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown AuthItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthItemMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthItemMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthItemMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AuthItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthItemMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AuthItem edge %s", name)
}

// AuthMsMutation represents an operation that mutates the AuthMs nodes in the graph.
type AuthMsMutation struct {
	config
	op            Op
	typ           string
	id            *int
	status        *int8
	addstatus     *int8
	create_at     *time.Time
	update_at     *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AuthMs, error)
	predicates    []predicate.AuthMs
}

var _ ent.Mutation = (*AuthMsMutation)(nil)

// authmsOption allows management of the mutation configuration using functional options.
type authmsOption func(*AuthMsMutation)

// newAuthMsMutation creates new mutation for the AuthMs entity.
func newAuthMsMutation(c config, op Op, opts ...authmsOption) *AuthMsMutation {
	m := &AuthMsMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthMs,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthMsID sets the ID field of the mutation.
func withAuthMsID(id int) authmsOption {
	return func(m *AuthMsMutation) {
		var (
			err   error
			once  sync.Once
			value *AuthMs
		)
		m.oldValue = func(ctx context.Context) (*AuthMs, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuthMs.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthMs sets the old AuthMs of the mutation.
func withAuthMs(node *AuthMs) authmsOption {
	return func(m *AuthMsMutation) {
		m.oldValue = func(context.Context) (*AuthMs, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthMsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthMsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *AuthMsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetStatus sets the "status" field.
func (m *AuthMsMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AuthMsMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AuthMs entity.
// If the AuthMs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMsMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AuthMsMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AuthMsMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *AuthMsMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetCreateAt sets the "create_at" field.
func (m *AuthMsMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *AuthMsMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the AuthMs entity.
// If the AuthMs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMsMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *AuthMsMutation) ResetCreateAt() {
	m.create_at = nil
}

// SetUpdateAt sets the "update_at" field.
func (m *AuthMsMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *AuthMsMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the AuthMs entity.
// If the AuthMs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMsMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *AuthMsMutation) ResetUpdateAt() {
	m.update_at = nil
}

// Op returns the operation name.
func (m *AuthMsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AuthMs).
func (m *AuthMsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthMsMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.status != nil {
		fields = append(fields, authms.FieldStatus)
	}
	if m.create_at != nil {
		fields = append(fields, authms.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, authms.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthMsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case authms.FieldStatus:
		return m.Status()
	case authms.FieldCreateAt:
		return m.CreateAt()
	case authms.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthMsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case authms.FieldStatus:
		return m.OldStatus(ctx)
	case authms.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case authms.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown AuthMs field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthMsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case authms.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case authms.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case authms.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown AuthMs field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthMsMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, authms.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthMsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case authms.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthMsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case authms.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown AuthMs numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthMsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthMsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthMsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AuthMs nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthMsMutation) ResetField(name string) error {
	switch name {
	case authms.FieldStatus:
		m.ResetStatus()
		return nil
	case authms.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case authms.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown AuthMs field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthMsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthMsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthMsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthMsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthMsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthMsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthMsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AuthMs unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthMsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AuthMs edge %s", name)
}

// AuthMsMenuMutation represents an operation that mutates the AuthMsMenu nodes in the graph.
type AuthMsMenuMutation struct {
	config
	op            Op
	typ           string
	id            *int
	status        *int8
	addstatus     *int8
	create_at     *time.Time
	update_at     *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AuthMsMenu, error)
	predicates    []predicate.AuthMsMenu
}

var _ ent.Mutation = (*AuthMsMenuMutation)(nil)

// authmsmenuOption allows management of the mutation configuration using functional options.
type authmsmenuOption func(*AuthMsMenuMutation)

// newAuthMsMenuMutation creates new mutation for the AuthMsMenu entity.
func newAuthMsMenuMutation(c config, op Op, opts ...authmsmenuOption) *AuthMsMenuMutation {
	m := &AuthMsMenuMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthMsMenu,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthMsMenuID sets the ID field of the mutation.
func withAuthMsMenuID(id int) authmsmenuOption {
	return func(m *AuthMsMenuMutation) {
		var (
			err   error
			once  sync.Once
			value *AuthMsMenu
		)
		m.oldValue = func(ctx context.Context) (*AuthMsMenu, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuthMsMenu.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthMsMenu sets the old AuthMsMenu of the mutation.
func withAuthMsMenu(node *AuthMsMenu) authmsmenuOption {
	return func(m *AuthMsMenuMutation) {
		m.oldValue = func(context.Context) (*AuthMsMenu, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthMsMenuMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthMsMenuMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *AuthMsMenuMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetStatus sets the "status" field.
func (m *AuthMsMenuMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AuthMsMenuMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AuthMsMenu entity.
// If the AuthMsMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMsMenuMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AuthMsMenuMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AuthMsMenuMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *AuthMsMenuMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetCreateAt sets the "create_at" field.
func (m *AuthMsMenuMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *AuthMsMenuMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the AuthMsMenu entity.
// If the AuthMsMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMsMenuMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *AuthMsMenuMutation) ResetCreateAt() {
	m.create_at = nil
}

// SetUpdateAt sets the "update_at" field.
func (m *AuthMsMenuMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *AuthMsMenuMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the AuthMsMenu entity.
// If the AuthMsMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMsMenuMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *AuthMsMenuMutation) ResetUpdateAt() {
	m.update_at = nil
}

// Op returns the operation name.
func (m *AuthMsMenuMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AuthMsMenu).
func (m *AuthMsMenuMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthMsMenuMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.status != nil {
		fields = append(fields, authmsmenu.FieldStatus)
	}
	if m.create_at != nil {
		fields = append(fields, authmsmenu.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, authmsmenu.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthMsMenuMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case authmsmenu.FieldStatus:
		return m.Status()
	case authmsmenu.FieldCreateAt:
		return m.CreateAt()
	case authmsmenu.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthMsMenuMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case authmsmenu.FieldStatus:
		return m.OldStatus(ctx)
	case authmsmenu.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case authmsmenu.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown AuthMsMenu field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthMsMenuMutation) SetField(name string, value ent.Value) error {
	switch name {
	case authmsmenu.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case authmsmenu.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case authmsmenu.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown AuthMsMenu field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthMsMenuMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, authmsmenu.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthMsMenuMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case authmsmenu.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthMsMenuMutation) AddField(name string, value ent.Value) error {
	switch name {
	case authmsmenu.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown AuthMsMenu numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthMsMenuMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthMsMenuMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthMsMenuMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AuthMsMenu nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthMsMenuMutation) ResetField(name string) error {
	switch name {
	case authmsmenu.FieldStatus:
		m.ResetStatus()
		return nil
	case authmsmenu.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case authmsmenu.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown AuthMsMenu field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthMsMenuMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthMsMenuMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthMsMenuMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthMsMenuMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthMsMenuMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthMsMenuMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthMsMenuMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AuthMsMenu unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthMsMenuMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AuthMsMenu edge %s", name)
}

// AuthRoleMutation represents an operation that mutates the AuthRole nodes in the graph.
type AuthRoleMutation struct {
	config
	op            Op
	typ           string
	id            *int
	status        *int8
	addstatus     *int8
	create_at     *time.Time
	update_at     *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AuthRole, error)
	predicates    []predicate.AuthRole
}

var _ ent.Mutation = (*AuthRoleMutation)(nil)

// authroleOption allows management of the mutation configuration using functional options.
type authroleOption func(*AuthRoleMutation)

// newAuthRoleMutation creates new mutation for the AuthRole entity.
func newAuthRoleMutation(c config, op Op, opts ...authroleOption) *AuthRoleMutation {
	m := &AuthRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthRoleID sets the ID field of the mutation.
func withAuthRoleID(id int) authroleOption {
	return func(m *AuthRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *AuthRole
		)
		m.oldValue = func(ctx context.Context) (*AuthRole, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuthRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthRole sets the old AuthRole of the mutation.
func withAuthRole(node *AuthRole) authroleOption {
	return func(m *AuthRoleMutation) {
		m.oldValue = func(context.Context) (*AuthRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *AuthRoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetStatus sets the "status" field.
func (m *AuthRoleMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AuthRoleMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AuthRole entity.
// If the AuthRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRoleMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AuthRoleMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AuthRoleMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *AuthRoleMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetCreateAt sets the "create_at" field.
func (m *AuthRoleMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *AuthRoleMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the AuthRole entity.
// If the AuthRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRoleMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *AuthRoleMutation) ResetCreateAt() {
	m.create_at = nil
}

// SetUpdateAt sets the "update_at" field.
func (m *AuthRoleMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *AuthRoleMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the AuthRole entity.
// If the AuthRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRoleMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *AuthRoleMutation) ResetUpdateAt() {
	m.update_at = nil
}

// Op returns the operation name.
func (m *AuthRoleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AuthRole).
func (m *AuthRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthRoleMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.status != nil {
		fields = append(fields, authrole.FieldStatus)
	}
	if m.create_at != nil {
		fields = append(fields, authrole.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, authrole.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case authrole.FieldStatus:
		return m.Status()
	case authrole.FieldCreateAt:
		return m.CreateAt()
	case authrole.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case authrole.FieldStatus:
		return m.OldStatus(ctx)
	case authrole.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case authrole.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown AuthRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case authrole.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case authrole.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case authrole.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown AuthRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthRoleMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, authrole.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthRoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case authrole.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case authrole.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown AuthRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthRoleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthRoleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AuthRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthRoleMutation) ResetField(name string) error {
	switch name {
	case authrole.FieldStatus:
		m.ResetStatus()
		return nil
	case authrole.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case authrole.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown AuthRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthRoleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthRoleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthRoleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthRoleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AuthRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthRoleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AuthRole edge %s", name)
}

// AuthRoleStaffMutation represents an operation that mutates the AuthRoleStaff nodes in the graph.
type AuthRoleStaffMutation struct {
	config
	op            Op
	typ           string
	id            *int
	status        *int8
	addstatus     *int8
	create_at     *time.Time
	update_at     *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AuthRoleStaff, error)
	predicates    []predicate.AuthRoleStaff
}

var _ ent.Mutation = (*AuthRoleStaffMutation)(nil)

// authrolestaffOption allows management of the mutation configuration using functional options.
type authrolestaffOption func(*AuthRoleStaffMutation)

// newAuthRoleStaffMutation creates new mutation for the AuthRoleStaff entity.
func newAuthRoleStaffMutation(c config, op Op, opts ...authrolestaffOption) *AuthRoleStaffMutation {
	m := &AuthRoleStaffMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthRoleStaff,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthRoleStaffID sets the ID field of the mutation.
func withAuthRoleStaffID(id int) authrolestaffOption {
	return func(m *AuthRoleStaffMutation) {
		var (
			err   error
			once  sync.Once
			value *AuthRoleStaff
		)
		m.oldValue = func(ctx context.Context) (*AuthRoleStaff, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuthRoleStaff.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthRoleStaff sets the old AuthRoleStaff of the mutation.
func withAuthRoleStaff(node *AuthRoleStaff) authrolestaffOption {
	return func(m *AuthRoleStaffMutation) {
		m.oldValue = func(context.Context) (*AuthRoleStaff, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthRoleStaffMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthRoleStaffMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *AuthRoleStaffMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetStatus sets the "status" field.
func (m *AuthRoleStaffMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AuthRoleStaffMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AuthRoleStaff entity.
// If the AuthRoleStaff object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRoleStaffMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AuthRoleStaffMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AuthRoleStaffMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *AuthRoleStaffMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetCreateAt sets the "create_at" field.
func (m *AuthRoleStaffMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *AuthRoleStaffMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the AuthRoleStaff entity.
// If the AuthRoleStaff object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRoleStaffMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *AuthRoleStaffMutation) ResetCreateAt() {
	m.create_at = nil
}

// SetUpdateAt sets the "update_at" field.
func (m *AuthRoleStaffMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *AuthRoleStaffMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the AuthRoleStaff entity.
// If the AuthRoleStaff object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRoleStaffMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *AuthRoleStaffMutation) ResetUpdateAt() {
	m.update_at = nil
}

// Op returns the operation name.
func (m *AuthRoleStaffMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AuthRoleStaff).
func (m *AuthRoleStaffMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthRoleStaffMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.status != nil {
		fields = append(fields, authrolestaff.FieldStatus)
	}
	if m.create_at != nil {
		fields = append(fields, authrolestaff.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, authrolestaff.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthRoleStaffMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case authrolestaff.FieldStatus:
		return m.Status()
	case authrolestaff.FieldCreateAt:
		return m.CreateAt()
	case authrolestaff.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthRoleStaffMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case authrolestaff.FieldStatus:
		return m.OldStatus(ctx)
	case authrolestaff.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case authrolestaff.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown AuthRoleStaff field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthRoleStaffMutation) SetField(name string, value ent.Value) error {
	switch name {
	case authrolestaff.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case authrolestaff.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case authrolestaff.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown AuthRoleStaff field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthRoleStaffMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, authrolestaff.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthRoleStaffMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case authrolestaff.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthRoleStaffMutation) AddField(name string, value ent.Value) error {
	switch name {
	case authrolestaff.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown AuthRoleStaff numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthRoleStaffMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthRoleStaffMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthRoleStaffMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AuthRoleStaff nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthRoleStaffMutation) ResetField(name string) error {
	switch name {
	case authrolestaff.FieldStatus:
		m.ResetStatus()
		return nil
	case authrolestaff.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case authrolestaff.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown AuthRoleStaff field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthRoleStaffMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthRoleStaffMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthRoleStaffMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthRoleStaffMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthRoleStaffMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthRoleStaffMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthRoleStaffMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AuthRoleStaff unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthRoleStaffMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AuthRoleStaff edge %s", name)
}

// ProductAttrMutation represents an operation that mutates the ProductAttr nodes in the graph.
type ProductAttrMutation struct {
	config
	op            Op
	typ           string
	id            *int
	status        *int8
	addstatus     *int8
	create_at     *time.Time
	update_at     *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ProductAttr, error)
	predicates    []predicate.ProductAttr
}

var _ ent.Mutation = (*ProductAttrMutation)(nil)

// productattrOption allows management of the mutation configuration using functional options.
type productattrOption func(*ProductAttrMutation)

// newProductAttrMutation creates new mutation for the ProductAttr entity.
func newProductAttrMutation(c config, op Op, opts ...productattrOption) *ProductAttrMutation {
	m := &ProductAttrMutation{
		config:        c,
		op:            op,
		typ:           TypeProductAttr,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductAttrID sets the ID field of the mutation.
func withProductAttrID(id int) productattrOption {
	return func(m *ProductAttrMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductAttr
		)
		m.oldValue = func(ctx context.Context) (*ProductAttr, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductAttr.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductAttr sets the old ProductAttr of the mutation.
func withProductAttr(node *ProductAttr) productattrOption {
	return func(m *ProductAttrMutation) {
		m.oldValue = func(context.Context) (*ProductAttr, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductAttrMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductAttrMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *ProductAttrMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetStatus sets the "status" field.
func (m *ProductAttrMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ProductAttrMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ProductAttr entity.
// If the ProductAttr object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAttrMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *ProductAttrMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ProductAttrMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *ProductAttrMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetCreateAt sets the "create_at" field.
func (m *ProductAttrMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *ProductAttrMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the ProductAttr entity.
// If the ProductAttr object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAttrMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *ProductAttrMutation) ResetCreateAt() {
	m.create_at = nil
}

// SetUpdateAt sets the "update_at" field.
func (m *ProductAttrMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *ProductAttrMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the ProductAttr entity.
// If the ProductAttr object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAttrMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *ProductAttrMutation) ResetUpdateAt() {
	m.update_at = nil
}

// Op returns the operation name.
func (m *ProductAttrMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProductAttr).
func (m *ProductAttrMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductAttrMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.status != nil {
		fields = append(fields, productattr.FieldStatus)
	}
	if m.create_at != nil {
		fields = append(fields, productattr.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, productattr.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductAttrMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productattr.FieldStatus:
		return m.Status()
	case productattr.FieldCreateAt:
		return m.CreateAt()
	case productattr.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductAttrMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productattr.FieldStatus:
		return m.OldStatus(ctx)
	case productattr.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case productattr.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown ProductAttr field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductAttrMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productattr.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case productattr.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case productattr.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProductAttr field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductAttrMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, productattr.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductAttrMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case productattr.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductAttrMutation) AddField(name string, value ent.Value) error {
	switch name {
	case productattr.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown ProductAttr numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductAttrMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductAttrMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductAttrMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProductAttr nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductAttrMutation) ResetField(name string) error {
	switch name {
	case productattr.FieldStatus:
		m.ResetStatus()
		return nil
	case productattr.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case productattr.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown ProductAttr field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductAttrMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductAttrMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductAttrMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductAttrMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductAttrMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductAttrMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductAttrMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ProductAttr unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductAttrMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ProductAttr edge %s", name)
}

// ProductAttrValueMutation represents an operation that mutates the ProductAttrValue nodes in the graph.
type ProductAttrValueMutation struct {
	config
	op            Op
	typ           string
	id            *int
	status        *int8
	addstatus     *int8
	create_at     *time.Time
	update_at     *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ProductAttrValue, error)
	predicates    []predicate.ProductAttrValue
}

var _ ent.Mutation = (*ProductAttrValueMutation)(nil)

// productattrvalueOption allows management of the mutation configuration using functional options.
type productattrvalueOption func(*ProductAttrValueMutation)

// newProductAttrValueMutation creates new mutation for the ProductAttrValue entity.
func newProductAttrValueMutation(c config, op Op, opts ...productattrvalueOption) *ProductAttrValueMutation {
	m := &ProductAttrValueMutation{
		config:        c,
		op:            op,
		typ:           TypeProductAttrValue,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductAttrValueID sets the ID field of the mutation.
func withProductAttrValueID(id int) productattrvalueOption {
	return func(m *ProductAttrValueMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductAttrValue
		)
		m.oldValue = func(ctx context.Context) (*ProductAttrValue, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductAttrValue.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductAttrValue sets the old ProductAttrValue of the mutation.
func withProductAttrValue(node *ProductAttrValue) productattrvalueOption {
	return func(m *ProductAttrValueMutation) {
		m.oldValue = func(context.Context) (*ProductAttrValue, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductAttrValueMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductAttrValueMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *ProductAttrValueMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetStatus sets the "status" field.
func (m *ProductAttrValueMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ProductAttrValueMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ProductAttrValue entity.
// If the ProductAttrValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAttrValueMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *ProductAttrValueMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ProductAttrValueMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *ProductAttrValueMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetCreateAt sets the "create_at" field.
func (m *ProductAttrValueMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *ProductAttrValueMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the ProductAttrValue entity.
// If the ProductAttrValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAttrValueMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *ProductAttrValueMutation) ResetCreateAt() {
	m.create_at = nil
}

// SetUpdateAt sets the "update_at" field.
func (m *ProductAttrValueMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *ProductAttrValueMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the ProductAttrValue entity.
// If the ProductAttrValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAttrValueMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *ProductAttrValueMutation) ResetUpdateAt() {
	m.update_at = nil
}

// Op returns the operation name.
func (m *ProductAttrValueMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProductAttrValue).
func (m *ProductAttrValueMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductAttrValueMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.status != nil {
		fields = append(fields, productattrvalue.FieldStatus)
	}
	if m.create_at != nil {
		fields = append(fields, productattrvalue.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, productattrvalue.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductAttrValueMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productattrvalue.FieldStatus:
		return m.Status()
	case productattrvalue.FieldCreateAt:
		return m.CreateAt()
	case productattrvalue.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductAttrValueMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productattrvalue.FieldStatus:
		return m.OldStatus(ctx)
	case productattrvalue.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case productattrvalue.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown ProductAttrValue field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductAttrValueMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productattrvalue.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case productattrvalue.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case productattrvalue.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProductAttrValue field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductAttrValueMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, productattrvalue.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductAttrValueMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case productattrvalue.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductAttrValueMutation) AddField(name string, value ent.Value) error {
	switch name {
	case productattrvalue.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown ProductAttrValue numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductAttrValueMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductAttrValueMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductAttrValueMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProductAttrValue nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductAttrValueMutation) ResetField(name string) error {
	switch name {
	case productattrvalue.FieldStatus:
		m.ResetStatus()
		return nil
	case productattrvalue.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case productattrvalue.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown ProductAttrValue field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductAttrValueMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductAttrValueMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductAttrValueMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductAttrValueMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductAttrValueMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductAttrValueMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductAttrValueMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ProductAttrValue unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductAttrValueMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ProductAttrValue edge %s", name)
}

// ProductBrandsMutation represents an operation that mutates the ProductBrands nodes in the graph.
type ProductBrandsMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	desc          *string
	logo_url      *string
	status        *int8
	addstatus     *int8
	create_at     *time.Time
	update_at     *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ProductBrands, error)
	predicates    []predicate.ProductBrands
}

var _ ent.Mutation = (*ProductBrandsMutation)(nil)

// productbrandsOption allows management of the mutation configuration using functional options.
type productbrandsOption func(*ProductBrandsMutation)

// newProductBrandsMutation creates new mutation for the ProductBrands entity.
func newProductBrandsMutation(c config, op Op, opts ...productbrandsOption) *ProductBrandsMutation {
	m := &ProductBrandsMutation{
		config:        c,
		op:            op,
		typ:           TypeProductBrands,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductBrandsID sets the ID field of the mutation.
func withProductBrandsID(id int) productbrandsOption {
	return func(m *ProductBrandsMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductBrands
		)
		m.oldValue = func(ctx context.Context) (*ProductBrands, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductBrands.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductBrands sets the old ProductBrands of the mutation.
func withProductBrands(node *ProductBrands) productbrandsOption {
	return func(m *ProductBrandsMutation) {
		m.oldValue = func(context.Context) (*ProductBrands, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductBrandsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductBrandsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *ProductBrandsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *ProductBrandsMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProductBrandsMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ProductBrands entity.
// If the ProductBrands object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductBrandsMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProductBrandsMutation) ResetName() {
	m.name = nil
}

// SetDesc sets the "desc" field.
func (m *ProductBrandsMutation) SetDesc(s string) {
	m.desc = &s
}

// Desc returns the value of the "desc" field in the mutation.
func (m *ProductBrandsMutation) Desc() (r string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the ProductBrands entity.
// If the ProductBrands object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductBrandsMutation) OldDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// ResetDesc resets all changes to the "desc" field.
func (m *ProductBrandsMutation) ResetDesc() {
	m.desc = nil
}

// SetLogoURL sets the "logo_url" field.
func (m *ProductBrandsMutation) SetLogoURL(s string) {
	m.logo_url = &s
}

// LogoURL returns the value of the "logo_url" field in the mutation.
func (m *ProductBrandsMutation) LogoURL() (r string, exists bool) {
	v := m.logo_url
	if v == nil {
		return
	}
	return *v, true
}

// OldLogoURL returns the old "logo_url" field's value of the ProductBrands entity.
// If the ProductBrands object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductBrandsMutation) OldLogoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLogoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLogoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogoURL: %w", err)
	}
	return oldValue.LogoURL, nil
}

// ResetLogoURL resets all changes to the "logo_url" field.
func (m *ProductBrandsMutation) ResetLogoURL() {
	m.logo_url = nil
}

// SetStatus sets the "status" field.
func (m *ProductBrandsMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ProductBrandsMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ProductBrands entity.
// If the ProductBrands object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductBrandsMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *ProductBrandsMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ProductBrandsMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *ProductBrandsMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetCreateAt sets the "create_at" field.
func (m *ProductBrandsMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *ProductBrandsMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the ProductBrands entity.
// If the ProductBrands object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductBrandsMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *ProductBrandsMutation) ResetCreateAt() {
	m.create_at = nil
}

// SetUpdateAt sets the "update_at" field.
func (m *ProductBrandsMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *ProductBrandsMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the ProductBrands entity.
// If the ProductBrands object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductBrandsMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *ProductBrandsMutation) ResetUpdateAt() {
	m.update_at = nil
}

// Op returns the operation name.
func (m *ProductBrandsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProductBrands).
func (m *ProductBrandsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductBrandsMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, productbrands.FieldName)
	}
	if m.desc != nil {
		fields = append(fields, productbrands.FieldDesc)
	}
	if m.logo_url != nil {
		fields = append(fields, productbrands.FieldLogoURL)
	}
	if m.status != nil {
		fields = append(fields, productbrands.FieldStatus)
	}
	if m.create_at != nil {
		fields = append(fields, productbrands.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, productbrands.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductBrandsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productbrands.FieldName:
		return m.Name()
	case productbrands.FieldDesc:
		return m.Desc()
	case productbrands.FieldLogoURL:
		return m.LogoURL()
	case productbrands.FieldStatus:
		return m.Status()
	case productbrands.FieldCreateAt:
		return m.CreateAt()
	case productbrands.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductBrandsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productbrands.FieldName:
		return m.OldName(ctx)
	case productbrands.FieldDesc:
		return m.OldDesc(ctx)
	case productbrands.FieldLogoURL:
		return m.OldLogoURL(ctx)
	case productbrands.FieldStatus:
		return m.OldStatus(ctx)
	case productbrands.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case productbrands.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown ProductBrands field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductBrandsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productbrands.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case productbrands.FieldDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case productbrands.FieldLogoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogoURL(v)
		return nil
	case productbrands.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case productbrands.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case productbrands.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProductBrands field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductBrandsMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, productbrands.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductBrandsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case productbrands.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductBrandsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case productbrands.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown ProductBrands numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductBrandsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductBrandsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductBrandsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProductBrands nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductBrandsMutation) ResetField(name string) error {
	switch name {
	case productbrands.FieldName:
		m.ResetName()
		return nil
	case productbrands.FieldDesc:
		m.ResetDesc()
		return nil
	case productbrands.FieldLogoURL:
		m.ResetLogoURL()
		return nil
	case productbrands.FieldStatus:
		m.ResetStatus()
		return nil
	case productbrands.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case productbrands.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown ProductBrands field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductBrandsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductBrandsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductBrandsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductBrandsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductBrandsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductBrandsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductBrandsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ProductBrands unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductBrandsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ProductBrands edge %s", name)
}

// ProductCategoryMutation represents an operation that mutates the ProductCategory nodes in the graph.
type ProductCategoryMutation struct {
	config
	op            Op
	typ           string
	id            *int
	pid           *int64
	addpid        *int64
	name          *string
	desc          *string
	pic_url       *string
	_path         *string
	status        *int8
	addstatus     *int8
	create_at     *time.Time
	update_at     *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ProductCategory, error)
	predicates    []predicate.ProductCategory
}

var _ ent.Mutation = (*ProductCategoryMutation)(nil)

// productcategoryOption allows management of the mutation configuration using functional options.
type productcategoryOption func(*ProductCategoryMutation)

// newProductCategoryMutation creates new mutation for the ProductCategory entity.
func newProductCategoryMutation(c config, op Op, opts ...productcategoryOption) *ProductCategoryMutation {
	m := &ProductCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeProductCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductCategoryID sets the ID field of the mutation.
func withProductCategoryID(id int) productcategoryOption {
	return func(m *ProductCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductCategory
		)
		m.oldValue = func(ctx context.Context) (*ProductCategory, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductCategory sets the old ProductCategory of the mutation.
func withProductCategory(node *ProductCategory) productcategoryOption {
	return func(m *ProductCategoryMutation) {
		m.oldValue = func(context.Context) (*ProductCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *ProductCategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPid sets the "pid" field.
func (m *ProductCategoryMutation) SetPid(i int64) {
	m.pid = &i
	m.addpid = nil
}

// Pid returns the value of the "pid" field in the mutation.
func (m *ProductCategoryMutation) Pid() (r int64, exists bool) {
	v := m.pid
	if v == nil {
		return
	}
	return *v, true
}

// OldPid returns the old "pid" field's value of the ProductCategory entity.
// If the ProductCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMutation) OldPid(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPid: %w", err)
	}
	return oldValue.Pid, nil
}

// AddPid adds i to the "pid" field.
func (m *ProductCategoryMutation) AddPid(i int64) {
	if m.addpid != nil {
		*m.addpid += i
	} else {
		m.addpid = &i
	}
}

// AddedPid returns the value that was added to the "pid" field in this mutation.
func (m *ProductCategoryMutation) AddedPid() (r int64, exists bool) {
	v := m.addpid
	if v == nil {
		return
	}
	return *v, true
}

// ResetPid resets all changes to the "pid" field.
func (m *ProductCategoryMutation) ResetPid() {
	m.pid = nil
	m.addpid = nil
}

// SetName sets the "name" field.
func (m *ProductCategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProductCategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ProductCategory entity.
// If the ProductCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProductCategoryMutation) ResetName() {
	m.name = nil
}

// SetDesc sets the "desc" field.
func (m *ProductCategoryMutation) SetDesc(s string) {
	m.desc = &s
}

// Desc returns the value of the "desc" field in the mutation.
func (m *ProductCategoryMutation) Desc() (r string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the ProductCategory entity.
// If the ProductCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMutation) OldDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// ResetDesc resets all changes to the "desc" field.
func (m *ProductCategoryMutation) ResetDesc() {
	m.desc = nil
}

// SetPicURL sets the "pic_url" field.
func (m *ProductCategoryMutation) SetPicURL(s string) {
	m.pic_url = &s
}

// PicURL returns the value of the "pic_url" field in the mutation.
func (m *ProductCategoryMutation) PicURL() (r string, exists bool) {
	v := m.pic_url
	if v == nil {
		return
	}
	return *v, true
}

// OldPicURL returns the old "pic_url" field's value of the ProductCategory entity.
// If the ProductCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMutation) OldPicURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPicURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPicURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPicURL: %w", err)
	}
	return oldValue.PicURL, nil
}

// ResetPicURL resets all changes to the "pic_url" field.
func (m *ProductCategoryMutation) ResetPicURL() {
	m.pic_url = nil
}

// SetPath sets the "path" field.
func (m *ProductCategoryMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *ProductCategoryMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the ProductCategory entity.
// If the ProductCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *ProductCategoryMutation) ResetPath() {
	m._path = nil
}

// SetStatus sets the "status" field.
func (m *ProductCategoryMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ProductCategoryMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ProductCategory entity.
// If the ProductCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *ProductCategoryMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ProductCategoryMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *ProductCategoryMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetCreateAt sets the "create_at" field.
func (m *ProductCategoryMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *ProductCategoryMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the ProductCategory entity.
// If the ProductCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *ProductCategoryMutation) ResetCreateAt() {
	m.create_at = nil
}

// SetUpdateAt sets the "update_at" field.
func (m *ProductCategoryMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *ProductCategoryMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the ProductCategory entity.
// If the ProductCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *ProductCategoryMutation) ResetUpdateAt() {
	m.update_at = nil
}

// Op returns the operation name.
func (m *ProductCategoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProductCategory).
func (m *ProductCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductCategoryMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.pid != nil {
		fields = append(fields, productcategory.FieldPid)
	}
	if m.name != nil {
		fields = append(fields, productcategory.FieldName)
	}
	if m.desc != nil {
		fields = append(fields, productcategory.FieldDesc)
	}
	if m.pic_url != nil {
		fields = append(fields, productcategory.FieldPicURL)
	}
	if m._path != nil {
		fields = append(fields, productcategory.FieldPath)
	}
	if m.status != nil {
		fields = append(fields, productcategory.FieldStatus)
	}
	if m.create_at != nil {
		fields = append(fields, productcategory.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, productcategory.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productcategory.FieldPid:
		return m.Pid()
	case productcategory.FieldName:
		return m.Name()
	case productcategory.FieldDesc:
		return m.Desc()
	case productcategory.FieldPicURL:
		return m.PicURL()
	case productcategory.FieldPath:
		return m.Path()
	case productcategory.FieldStatus:
		return m.Status()
	case productcategory.FieldCreateAt:
		return m.CreateAt()
	case productcategory.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productcategory.FieldPid:
		return m.OldPid(ctx)
	case productcategory.FieldName:
		return m.OldName(ctx)
	case productcategory.FieldDesc:
		return m.OldDesc(ctx)
	case productcategory.FieldPicURL:
		return m.OldPicURL(ctx)
	case productcategory.FieldPath:
		return m.OldPath(ctx)
	case productcategory.FieldStatus:
		return m.OldStatus(ctx)
	case productcategory.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case productcategory.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown ProductCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productcategory.FieldPid:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPid(v)
		return nil
	case productcategory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case productcategory.FieldDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case productcategory.FieldPicURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPicURL(v)
		return nil
	case productcategory.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case productcategory.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case productcategory.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case productcategory.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProductCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductCategoryMutation) AddedFields() []string {
	var fields []string
	if m.addpid != nil {
		fields = append(fields, productcategory.FieldPid)
	}
	if m.addstatus != nil {
		fields = append(fields, productcategory.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductCategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case productcategory.FieldPid:
		return m.AddedPid()
	case productcategory.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case productcategory.FieldPid:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPid(v)
		return nil
	case productcategory.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown ProductCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductCategoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductCategoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProductCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductCategoryMutation) ResetField(name string) error {
	switch name {
	case productcategory.FieldPid:
		m.ResetPid()
		return nil
	case productcategory.FieldName:
		m.ResetName()
		return nil
	case productcategory.FieldDesc:
		m.ResetDesc()
		return nil
	case productcategory.FieldPicURL:
		m.ResetPicURL()
		return nil
	case productcategory.FieldPath:
		m.ResetPath()
		return nil
	case productcategory.FieldStatus:
		m.ResetStatus()
		return nil
	case productcategory.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case productcategory.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown ProductCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductCategoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductCategoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductCategoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductCategoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ProductCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductCategoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ProductCategory edge %s", name)
}

// ProductSkuMutation represents an operation that mutates the ProductSku nodes in the graph.
type ProductSkuMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	spu_id                *int64
	addspu_id             *int64
	attrs                 *string
	banner_url            *string
	main_url              *string
	price_fee             *int64
	addprice_fee          *int64
	price_scale           *int8
	addprice_scale        *int8
	market_price_fee      *int64
	addmarket_price_fee   *int64
	market_price_scale    *int8
	addmarket_price_scale *int8
	create_at             *time.Time
	update_at             *time.Time
	status                *int8
	addstatus             *int8
	clearedFields         map[string]struct{}
	done                  bool
	oldValue              func(context.Context) (*ProductSku, error)
	predicates            []predicate.ProductSku
}

var _ ent.Mutation = (*ProductSkuMutation)(nil)

// productskuOption allows management of the mutation configuration using functional options.
type productskuOption func(*ProductSkuMutation)

// newProductSkuMutation creates new mutation for the ProductSku entity.
func newProductSkuMutation(c config, op Op, opts ...productskuOption) *ProductSkuMutation {
	m := &ProductSkuMutation{
		config:        c,
		op:            op,
		typ:           TypeProductSku,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductSkuID sets the ID field of the mutation.
func withProductSkuID(id int) productskuOption {
	return func(m *ProductSkuMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductSku
		)
		m.oldValue = func(ctx context.Context) (*ProductSku, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductSku.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductSku sets the old ProductSku of the mutation.
func withProductSku(node *ProductSku) productskuOption {
	return func(m *ProductSkuMutation) {
		m.oldValue = func(context.Context) (*ProductSku, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductSkuMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductSkuMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *ProductSkuMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSpuID sets the "spu_id" field.
func (m *ProductSkuMutation) SetSpuID(i int64) {
	m.spu_id = &i
	m.addspu_id = nil
}

// SpuID returns the value of the "spu_id" field in the mutation.
func (m *ProductSkuMutation) SpuID() (r int64, exists bool) {
	v := m.spu_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSpuID returns the old "spu_id" field's value of the ProductSku entity.
// If the ProductSku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSkuMutation) OldSpuID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSpuID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSpuID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpuID: %w", err)
	}
	return oldValue.SpuID, nil
}

// AddSpuID adds i to the "spu_id" field.
func (m *ProductSkuMutation) AddSpuID(i int64) {
	if m.addspu_id != nil {
		*m.addspu_id += i
	} else {
		m.addspu_id = &i
	}
}

// AddedSpuID returns the value that was added to the "spu_id" field in this mutation.
func (m *ProductSkuMutation) AddedSpuID() (r int64, exists bool) {
	v := m.addspu_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetSpuID resets all changes to the "spu_id" field.
func (m *ProductSkuMutation) ResetSpuID() {
	m.spu_id = nil
	m.addspu_id = nil
}

// SetAttrs sets the "attrs" field.
func (m *ProductSkuMutation) SetAttrs(s string) {
	m.attrs = &s
}

// Attrs returns the value of the "attrs" field in the mutation.
func (m *ProductSkuMutation) Attrs() (r string, exists bool) {
	v := m.attrs
	if v == nil {
		return
	}
	return *v, true
}

// OldAttrs returns the old "attrs" field's value of the ProductSku entity.
// If the ProductSku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSkuMutation) OldAttrs(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAttrs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAttrs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttrs: %w", err)
	}
	return oldValue.Attrs, nil
}

// ResetAttrs resets all changes to the "attrs" field.
func (m *ProductSkuMutation) ResetAttrs() {
	m.attrs = nil
}

// SetBannerURL sets the "banner_url" field.
func (m *ProductSkuMutation) SetBannerURL(s string) {
	m.banner_url = &s
}

// BannerURL returns the value of the "banner_url" field in the mutation.
func (m *ProductSkuMutation) BannerURL() (r string, exists bool) {
	v := m.banner_url
	if v == nil {
		return
	}
	return *v, true
}

// OldBannerURL returns the old "banner_url" field's value of the ProductSku entity.
// If the ProductSku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSkuMutation) OldBannerURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBannerURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBannerURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBannerURL: %w", err)
	}
	return oldValue.BannerURL, nil
}

// ResetBannerURL resets all changes to the "banner_url" field.
func (m *ProductSkuMutation) ResetBannerURL() {
	m.banner_url = nil
}

// SetMainURL sets the "main_url" field.
func (m *ProductSkuMutation) SetMainURL(s string) {
	m.main_url = &s
}

// MainURL returns the value of the "main_url" field in the mutation.
func (m *ProductSkuMutation) MainURL() (r string, exists bool) {
	v := m.main_url
	if v == nil {
		return
	}
	return *v, true
}

// OldMainURL returns the old "main_url" field's value of the ProductSku entity.
// If the ProductSku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSkuMutation) OldMainURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMainURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMainURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMainURL: %w", err)
	}
	return oldValue.MainURL, nil
}

// ResetMainURL resets all changes to the "main_url" field.
func (m *ProductSkuMutation) ResetMainURL() {
	m.main_url = nil
}

// SetPriceFee sets the "price_fee" field.
func (m *ProductSkuMutation) SetPriceFee(i int64) {
	m.price_fee = &i
	m.addprice_fee = nil
}

// PriceFee returns the value of the "price_fee" field in the mutation.
func (m *ProductSkuMutation) PriceFee() (r int64, exists bool) {
	v := m.price_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldPriceFee returns the old "price_fee" field's value of the ProductSku entity.
// If the ProductSku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSkuMutation) OldPriceFee(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPriceFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPriceFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriceFee: %w", err)
	}
	return oldValue.PriceFee, nil
}

// AddPriceFee adds i to the "price_fee" field.
func (m *ProductSkuMutation) AddPriceFee(i int64) {
	if m.addprice_fee != nil {
		*m.addprice_fee += i
	} else {
		m.addprice_fee = &i
	}
}

// AddedPriceFee returns the value that was added to the "price_fee" field in this mutation.
func (m *ProductSkuMutation) AddedPriceFee() (r int64, exists bool) {
	v := m.addprice_fee
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriceFee resets all changes to the "price_fee" field.
func (m *ProductSkuMutation) ResetPriceFee() {
	m.price_fee = nil
	m.addprice_fee = nil
}

// SetPriceScale sets the "price_scale" field.
func (m *ProductSkuMutation) SetPriceScale(i int8) {
	m.price_scale = &i
	m.addprice_scale = nil
}

// PriceScale returns the value of the "price_scale" field in the mutation.
func (m *ProductSkuMutation) PriceScale() (r int8, exists bool) {
	v := m.price_scale
	if v == nil {
		return
	}
	return *v, true
}

// OldPriceScale returns the old "price_scale" field's value of the ProductSku entity.
// If the ProductSku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSkuMutation) OldPriceScale(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPriceScale is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPriceScale requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriceScale: %w", err)
	}
	return oldValue.PriceScale, nil
}

// AddPriceScale adds i to the "price_scale" field.
func (m *ProductSkuMutation) AddPriceScale(i int8) {
	if m.addprice_scale != nil {
		*m.addprice_scale += i
	} else {
		m.addprice_scale = &i
	}
}

// AddedPriceScale returns the value that was added to the "price_scale" field in this mutation.
func (m *ProductSkuMutation) AddedPriceScale() (r int8, exists bool) {
	v := m.addprice_scale
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriceScale resets all changes to the "price_scale" field.
func (m *ProductSkuMutation) ResetPriceScale() {
	m.price_scale = nil
	m.addprice_scale = nil
}

// SetMarketPriceFee sets the "market_price_fee" field.
func (m *ProductSkuMutation) SetMarketPriceFee(i int64) {
	m.market_price_fee = &i
	m.addmarket_price_fee = nil
}

// MarketPriceFee returns the value of the "market_price_fee" field in the mutation.
func (m *ProductSkuMutation) MarketPriceFee() (r int64, exists bool) {
	v := m.market_price_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldMarketPriceFee returns the old "market_price_fee" field's value of the ProductSku entity.
// If the ProductSku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSkuMutation) OldMarketPriceFee(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMarketPriceFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMarketPriceFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMarketPriceFee: %w", err)
	}
	return oldValue.MarketPriceFee, nil
}

// AddMarketPriceFee adds i to the "market_price_fee" field.
func (m *ProductSkuMutation) AddMarketPriceFee(i int64) {
	if m.addmarket_price_fee != nil {
		*m.addmarket_price_fee += i
	} else {
		m.addmarket_price_fee = &i
	}
}

// AddedMarketPriceFee returns the value that was added to the "market_price_fee" field in this mutation.
func (m *ProductSkuMutation) AddedMarketPriceFee() (r int64, exists bool) {
	v := m.addmarket_price_fee
	if v == nil {
		return
	}
	return *v, true
}

// ResetMarketPriceFee resets all changes to the "market_price_fee" field.
func (m *ProductSkuMutation) ResetMarketPriceFee() {
	m.market_price_fee = nil
	m.addmarket_price_fee = nil
}

// SetMarketPriceScale sets the "market_price_scale" field.
func (m *ProductSkuMutation) SetMarketPriceScale(i int8) {
	m.market_price_scale = &i
	m.addmarket_price_scale = nil
}

// MarketPriceScale returns the value of the "market_price_scale" field in the mutation.
func (m *ProductSkuMutation) MarketPriceScale() (r int8, exists bool) {
	v := m.market_price_scale
	if v == nil {
		return
	}
	return *v, true
}

// OldMarketPriceScale returns the old "market_price_scale" field's value of the ProductSku entity.
// If the ProductSku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSkuMutation) OldMarketPriceScale(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMarketPriceScale is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMarketPriceScale requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMarketPriceScale: %w", err)
	}
	return oldValue.MarketPriceScale, nil
}

// AddMarketPriceScale adds i to the "market_price_scale" field.
func (m *ProductSkuMutation) AddMarketPriceScale(i int8) {
	if m.addmarket_price_scale != nil {
		*m.addmarket_price_scale += i
	} else {
		m.addmarket_price_scale = &i
	}
}

// AddedMarketPriceScale returns the value that was added to the "market_price_scale" field in this mutation.
func (m *ProductSkuMutation) AddedMarketPriceScale() (r int8, exists bool) {
	v := m.addmarket_price_scale
	if v == nil {
		return
	}
	return *v, true
}

// ResetMarketPriceScale resets all changes to the "market_price_scale" field.
func (m *ProductSkuMutation) ResetMarketPriceScale() {
	m.market_price_scale = nil
	m.addmarket_price_scale = nil
}

// SetCreateAt sets the "create_at" field.
func (m *ProductSkuMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *ProductSkuMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the ProductSku entity.
// If the ProductSku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSkuMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *ProductSkuMutation) ResetCreateAt() {
	m.create_at = nil
}

// SetUpdateAt sets the "update_at" field.
func (m *ProductSkuMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *ProductSkuMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the ProductSku entity.
// If the ProductSku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSkuMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *ProductSkuMutation) ResetUpdateAt() {
	m.update_at = nil
}

// SetStatus sets the "status" field.
func (m *ProductSkuMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ProductSkuMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ProductSku entity.
// If the ProductSku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSkuMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *ProductSkuMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ProductSkuMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *ProductSkuMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// Op returns the operation name.
func (m *ProductSkuMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProductSku).
func (m *ProductSkuMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductSkuMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.spu_id != nil {
		fields = append(fields, productsku.FieldSpuID)
	}
	if m.attrs != nil {
		fields = append(fields, productsku.FieldAttrs)
	}
	if m.banner_url != nil {
		fields = append(fields, productsku.FieldBannerURL)
	}
	if m.main_url != nil {
		fields = append(fields, productsku.FieldMainURL)
	}
	if m.price_fee != nil {
		fields = append(fields, productsku.FieldPriceFee)
	}
	if m.price_scale != nil {
		fields = append(fields, productsku.FieldPriceScale)
	}
	if m.market_price_fee != nil {
		fields = append(fields, productsku.FieldMarketPriceFee)
	}
	if m.market_price_scale != nil {
		fields = append(fields, productsku.FieldMarketPriceScale)
	}
	if m.create_at != nil {
		fields = append(fields, productsku.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, productsku.FieldUpdateAt)
	}
	if m.status != nil {
		fields = append(fields, productsku.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductSkuMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productsku.FieldSpuID:
		return m.SpuID()
	case productsku.FieldAttrs:
		return m.Attrs()
	case productsku.FieldBannerURL:
		return m.BannerURL()
	case productsku.FieldMainURL:
		return m.MainURL()
	case productsku.FieldPriceFee:
		return m.PriceFee()
	case productsku.FieldPriceScale:
		return m.PriceScale()
	case productsku.FieldMarketPriceFee:
		return m.MarketPriceFee()
	case productsku.FieldMarketPriceScale:
		return m.MarketPriceScale()
	case productsku.FieldCreateAt:
		return m.CreateAt()
	case productsku.FieldUpdateAt:
		return m.UpdateAt()
	case productsku.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductSkuMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productsku.FieldSpuID:
		return m.OldSpuID(ctx)
	case productsku.FieldAttrs:
		return m.OldAttrs(ctx)
	case productsku.FieldBannerURL:
		return m.OldBannerURL(ctx)
	case productsku.FieldMainURL:
		return m.OldMainURL(ctx)
	case productsku.FieldPriceFee:
		return m.OldPriceFee(ctx)
	case productsku.FieldPriceScale:
		return m.OldPriceScale(ctx)
	case productsku.FieldMarketPriceFee:
		return m.OldMarketPriceFee(ctx)
	case productsku.FieldMarketPriceScale:
		return m.OldMarketPriceScale(ctx)
	case productsku.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case productsku.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	case productsku.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown ProductSku field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductSkuMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productsku.FieldSpuID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpuID(v)
		return nil
	case productsku.FieldAttrs:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttrs(v)
		return nil
	case productsku.FieldBannerURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBannerURL(v)
		return nil
	case productsku.FieldMainURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMainURL(v)
		return nil
	case productsku.FieldPriceFee:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriceFee(v)
		return nil
	case productsku.FieldPriceScale:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriceScale(v)
		return nil
	case productsku.FieldMarketPriceFee:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMarketPriceFee(v)
		return nil
	case productsku.FieldMarketPriceScale:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMarketPriceScale(v)
		return nil
	case productsku.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case productsku.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	case productsku.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown ProductSku field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductSkuMutation) AddedFields() []string {
	var fields []string
	if m.addspu_id != nil {
		fields = append(fields, productsku.FieldSpuID)
	}
	if m.addprice_fee != nil {
		fields = append(fields, productsku.FieldPriceFee)
	}
	if m.addprice_scale != nil {
		fields = append(fields, productsku.FieldPriceScale)
	}
	if m.addmarket_price_fee != nil {
		fields = append(fields, productsku.FieldMarketPriceFee)
	}
	if m.addmarket_price_scale != nil {
		fields = append(fields, productsku.FieldMarketPriceScale)
	}
	if m.addstatus != nil {
		fields = append(fields, productsku.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductSkuMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case productsku.FieldSpuID:
		return m.AddedSpuID()
	case productsku.FieldPriceFee:
		return m.AddedPriceFee()
	case productsku.FieldPriceScale:
		return m.AddedPriceScale()
	case productsku.FieldMarketPriceFee:
		return m.AddedMarketPriceFee()
	case productsku.FieldMarketPriceScale:
		return m.AddedMarketPriceScale()
	case productsku.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductSkuMutation) AddField(name string, value ent.Value) error {
	switch name {
	case productsku.FieldSpuID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSpuID(v)
		return nil
	case productsku.FieldPriceFee:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriceFee(v)
		return nil
	case productsku.FieldPriceScale:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriceScale(v)
		return nil
	case productsku.FieldMarketPriceFee:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMarketPriceFee(v)
		return nil
	case productsku.FieldMarketPriceScale:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMarketPriceScale(v)
		return nil
	case productsku.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown ProductSku numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductSkuMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductSkuMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductSkuMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProductSku nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductSkuMutation) ResetField(name string) error {
	switch name {
	case productsku.FieldSpuID:
		m.ResetSpuID()
		return nil
	case productsku.FieldAttrs:
		m.ResetAttrs()
		return nil
	case productsku.FieldBannerURL:
		m.ResetBannerURL()
		return nil
	case productsku.FieldMainURL:
		m.ResetMainURL()
		return nil
	case productsku.FieldPriceFee:
		m.ResetPriceFee()
		return nil
	case productsku.FieldPriceScale:
		m.ResetPriceScale()
		return nil
	case productsku.FieldMarketPriceFee:
		m.ResetMarketPriceFee()
		return nil
	case productsku.FieldMarketPriceScale:
		m.ResetMarketPriceScale()
		return nil
	case productsku.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case productsku.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	case productsku.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown ProductSku field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductSkuMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductSkuMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductSkuMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductSkuMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductSkuMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductSkuMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductSkuMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ProductSku unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductSkuMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ProductSku edge %s", name)
}

// ProductSkuStockMutation represents an operation that mutates the ProductSkuStock nodes in the graph.
type ProductSkuStockMutation struct {
	config
	op            Op
	typ           string
	id            *int
	create_at     *time.Time
	update_at     *time.Time
	status        *int8
	addstatus     *int8
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ProductSkuStock, error)
	predicates    []predicate.ProductSkuStock
}

var _ ent.Mutation = (*ProductSkuStockMutation)(nil)

// productskustockOption allows management of the mutation configuration using functional options.
type productskustockOption func(*ProductSkuStockMutation)

// newProductSkuStockMutation creates new mutation for the ProductSkuStock entity.
func newProductSkuStockMutation(c config, op Op, opts ...productskustockOption) *ProductSkuStockMutation {
	m := &ProductSkuStockMutation{
		config:        c,
		op:            op,
		typ:           TypeProductSkuStock,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductSkuStockID sets the ID field of the mutation.
func withProductSkuStockID(id int) productskustockOption {
	return func(m *ProductSkuStockMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductSkuStock
		)
		m.oldValue = func(ctx context.Context) (*ProductSkuStock, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductSkuStock.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductSkuStock sets the old ProductSkuStock of the mutation.
func withProductSkuStock(node *ProductSkuStock) productskustockOption {
	return func(m *ProductSkuStockMutation) {
		m.oldValue = func(context.Context) (*ProductSkuStock, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductSkuStockMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductSkuStockMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *ProductSkuStockMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateAt sets the "create_at" field.
func (m *ProductSkuStockMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *ProductSkuStockMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the ProductSkuStock entity.
// If the ProductSkuStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSkuStockMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *ProductSkuStockMutation) ResetCreateAt() {
	m.create_at = nil
}

// SetUpdateAt sets the "update_at" field.
func (m *ProductSkuStockMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *ProductSkuStockMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the ProductSkuStock entity.
// If the ProductSkuStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSkuStockMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *ProductSkuStockMutation) ResetUpdateAt() {
	m.update_at = nil
}

// SetStatus sets the "status" field.
func (m *ProductSkuStockMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ProductSkuStockMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ProductSkuStock entity.
// If the ProductSkuStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSkuStockMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *ProductSkuStockMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ProductSkuStockMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *ProductSkuStockMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// Op returns the operation name.
func (m *ProductSkuStockMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProductSkuStock).
func (m *ProductSkuStockMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductSkuStockMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_at != nil {
		fields = append(fields, productskustock.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, productskustock.FieldUpdateAt)
	}
	if m.status != nil {
		fields = append(fields, productskustock.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductSkuStockMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productskustock.FieldCreateAt:
		return m.CreateAt()
	case productskustock.FieldUpdateAt:
		return m.UpdateAt()
	case productskustock.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductSkuStockMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productskustock.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case productskustock.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	case productskustock.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown ProductSkuStock field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductSkuStockMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productskustock.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case productskustock.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	case productskustock.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown ProductSkuStock field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductSkuStockMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, productskustock.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductSkuStockMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case productskustock.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductSkuStockMutation) AddField(name string, value ent.Value) error {
	switch name {
	case productskustock.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown ProductSkuStock numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductSkuStockMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductSkuStockMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductSkuStockMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProductSkuStock nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductSkuStockMutation) ResetField(name string) error {
	switch name {
	case productskustock.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case productskustock.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	case productskustock.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown ProductSkuStock field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductSkuStockMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductSkuStockMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductSkuStockMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductSkuStockMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductSkuStockMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductSkuStockMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductSkuStockMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ProductSkuStock unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductSkuStockMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ProductSkuStock edge %s", name)
}

// ProductSpuMutation represents an operation that mutates the ProductSpu nodes in the graph.
type ProductSpuMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	brand_id              *int64
	addbrand_id           *int64
	category_id           *int64
	addcategory_id        *int64
	name                  *string
	desc                  *string
	selling_point         *string
	unit                  *string
	banner_url            *string
	main_url              *string
	price_fee             *int64
	addprice_fee          *int64
	price_scale           *int8
	addprice_scale        *int8
	market_price_fee      *int64
	addmarket_price_fee   *int64
	market_price_scale    *int8
	addmarket_price_scale *int8
	create_at             *time.Time
	update_at             *time.Time
	status                *int8
	addstatus             *int8
	clearedFields         map[string]struct{}
	done                  bool
	oldValue              func(context.Context) (*ProductSpu, error)
	predicates            []predicate.ProductSpu
}

var _ ent.Mutation = (*ProductSpuMutation)(nil)

// productspuOption allows management of the mutation configuration using functional options.
type productspuOption func(*ProductSpuMutation)

// newProductSpuMutation creates new mutation for the ProductSpu entity.
func newProductSpuMutation(c config, op Op, opts ...productspuOption) *ProductSpuMutation {
	m := &ProductSpuMutation{
		config:        c,
		op:            op,
		typ:           TypeProductSpu,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductSpuID sets the ID field of the mutation.
func withProductSpuID(id int) productspuOption {
	return func(m *ProductSpuMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductSpu
		)
		m.oldValue = func(ctx context.Context) (*ProductSpu, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductSpu.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductSpu sets the old ProductSpu of the mutation.
func withProductSpu(node *ProductSpu) productspuOption {
	return func(m *ProductSpuMutation) {
		m.oldValue = func(context.Context) (*ProductSpu, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductSpuMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductSpuMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *ProductSpuMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetBrandID sets the "brand_id" field.
func (m *ProductSpuMutation) SetBrandID(i int64) {
	m.brand_id = &i
	m.addbrand_id = nil
}

// BrandID returns the value of the "brand_id" field in the mutation.
func (m *ProductSpuMutation) BrandID() (r int64, exists bool) {
	v := m.brand_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBrandID returns the old "brand_id" field's value of the ProductSpu entity.
// If the ProductSpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpuMutation) OldBrandID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBrandID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBrandID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrandID: %w", err)
	}
	return oldValue.BrandID, nil
}

// AddBrandID adds i to the "brand_id" field.
func (m *ProductSpuMutation) AddBrandID(i int64) {
	if m.addbrand_id != nil {
		*m.addbrand_id += i
	} else {
		m.addbrand_id = &i
	}
}

// AddedBrandID returns the value that was added to the "brand_id" field in this mutation.
func (m *ProductSpuMutation) AddedBrandID() (r int64, exists bool) {
	v := m.addbrand_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetBrandID resets all changes to the "brand_id" field.
func (m *ProductSpuMutation) ResetBrandID() {
	m.brand_id = nil
	m.addbrand_id = nil
}

// SetCategoryID sets the "category_id" field.
func (m *ProductSpuMutation) SetCategoryID(i int64) {
	m.category_id = &i
	m.addcategory_id = nil
}

// CategoryID returns the value of the "category_id" field in the mutation.
func (m *ProductSpuMutation) CategoryID() (r int64, exists bool) {
	v := m.category_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryID returns the old "category_id" field's value of the ProductSpu entity.
// If the ProductSpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpuMutation) OldCategoryID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryID: %w", err)
	}
	return oldValue.CategoryID, nil
}

// AddCategoryID adds i to the "category_id" field.
func (m *ProductSpuMutation) AddCategoryID(i int64) {
	if m.addcategory_id != nil {
		*m.addcategory_id += i
	} else {
		m.addcategory_id = &i
	}
}

// AddedCategoryID returns the value that was added to the "category_id" field in this mutation.
func (m *ProductSpuMutation) AddedCategoryID() (r int64, exists bool) {
	v := m.addcategory_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCategoryID resets all changes to the "category_id" field.
func (m *ProductSpuMutation) ResetCategoryID() {
	m.category_id = nil
	m.addcategory_id = nil
}

// SetName sets the "name" field.
func (m *ProductSpuMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProductSpuMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ProductSpu entity.
// If the ProductSpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpuMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProductSpuMutation) ResetName() {
	m.name = nil
}

// SetDesc sets the "desc" field.
func (m *ProductSpuMutation) SetDesc(s string) {
	m.desc = &s
}

// Desc returns the value of the "desc" field in the mutation.
func (m *ProductSpuMutation) Desc() (r string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the ProductSpu entity.
// If the ProductSpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpuMutation) OldDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// ResetDesc resets all changes to the "desc" field.
func (m *ProductSpuMutation) ResetDesc() {
	m.desc = nil
}

// SetSellingPoint sets the "selling_point" field.
func (m *ProductSpuMutation) SetSellingPoint(s string) {
	m.selling_point = &s
}

// SellingPoint returns the value of the "selling_point" field in the mutation.
func (m *ProductSpuMutation) SellingPoint() (r string, exists bool) {
	v := m.selling_point
	if v == nil {
		return
	}
	return *v, true
}

// OldSellingPoint returns the old "selling_point" field's value of the ProductSpu entity.
// If the ProductSpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpuMutation) OldSellingPoint(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSellingPoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSellingPoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSellingPoint: %w", err)
	}
	return oldValue.SellingPoint, nil
}

// ResetSellingPoint resets all changes to the "selling_point" field.
func (m *ProductSpuMutation) ResetSellingPoint() {
	m.selling_point = nil
}

// SetUnit sets the "unit" field.
func (m *ProductSpuMutation) SetUnit(s string) {
	m.unit = &s
}

// Unit returns the value of the "unit" field in the mutation.
func (m *ProductSpuMutation) Unit() (r string, exists bool) {
	v := m.unit
	if v == nil {
		return
	}
	return *v, true
}

// OldUnit returns the old "unit" field's value of the ProductSpu entity.
// If the ProductSpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpuMutation) OldUnit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnit: %w", err)
	}
	return oldValue.Unit, nil
}

// ResetUnit resets all changes to the "unit" field.
func (m *ProductSpuMutation) ResetUnit() {
	m.unit = nil
}

// SetBannerURL sets the "banner_url" field.
func (m *ProductSpuMutation) SetBannerURL(s string) {
	m.banner_url = &s
}

// BannerURL returns the value of the "banner_url" field in the mutation.
func (m *ProductSpuMutation) BannerURL() (r string, exists bool) {
	v := m.banner_url
	if v == nil {
		return
	}
	return *v, true
}

// OldBannerURL returns the old "banner_url" field's value of the ProductSpu entity.
// If the ProductSpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpuMutation) OldBannerURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBannerURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBannerURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBannerURL: %w", err)
	}
	return oldValue.BannerURL, nil
}

// ResetBannerURL resets all changes to the "banner_url" field.
func (m *ProductSpuMutation) ResetBannerURL() {
	m.banner_url = nil
}

// SetMainURL sets the "main_url" field.
func (m *ProductSpuMutation) SetMainURL(s string) {
	m.main_url = &s
}

// MainURL returns the value of the "main_url" field in the mutation.
func (m *ProductSpuMutation) MainURL() (r string, exists bool) {
	v := m.main_url
	if v == nil {
		return
	}
	return *v, true
}

// OldMainURL returns the old "main_url" field's value of the ProductSpu entity.
// If the ProductSpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpuMutation) OldMainURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMainURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMainURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMainURL: %w", err)
	}
	return oldValue.MainURL, nil
}

// ResetMainURL resets all changes to the "main_url" field.
func (m *ProductSpuMutation) ResetMainURL() {
	m.main_url = nil
}

// SetPriceFee sets the "price_fee" field.
func (m *ProductSpuMutation) SetPriceFee(i int64) {
	m.price_fee = &i
	m.addprice_fee = nil
}

// PriceFee returns the value of the "price_fee" field in the mutation.
func (m *ProductSpuMutation) PriceFee() (r int64, exists bool) {
	v := m.price_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldPriceFee returns the old "price_fee" field's value of the ProductSpu entity.
// If the ProductSpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpuMutation) OldPriceFee(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPriceFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPriceFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriceFee: %w", err)
	}
	return oldValue.PriceFee, nil
}

// AddPriceFee adds i to the "price_fee" field.
func (m *ProductSpuMutation) AddPriceFee(i int64) {
	if m.addprice_fee != nil {
		*m.addprice_fee += i
	} else {
		m.addprice_fee = &i
	}
}

// AddedPriceFee returns the value that was added to the "price_fee" field in this mutation.
func (m *ProductSpuMutation) AddedPriceFee() (r int64, exists bool) {
	v := m.addprice_fee
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriceFee resets all changes to the "price_fee" field.
func (m *ProductSpuMutation) ResetPriceFee() {
	m.price_fee = nil
	m.addprice_fee = nil
}

// SetPriceScale sets the "price_scale" field.
func (m *ProductSpuMutation) SetPriceScale(i int8) {
	m.price_scale = &i
	m.addprice_scale = nil
}

// PriceScale returns the value of the "price_scale" field in the mutation.
func (m *ProductSpuMutation) PriceScale() (r int8, exists bool) {
	v := m.price_scale
	if v == nil {
		return
	}
	return *v, true
}

// OldPriceScale returns the old "price_scale" field's value of the ProductSpu entity.
// If the ProductSpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpuMutation) OldPriceScale(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPriceScale is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPriceScale requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriceScale: %w", err)
	}
	return oldValue.PriceScale, nil
}

// AddPriceScale adds i to the "price_scale" field.
func (m *ProductSpuMutation) AddPriceScale(i int8) {
	if m.addprice_scale != nil {
		*m.addprice_scale += i
	} else {
		m.addprice_scale = &i
	}
}

// AddedPriceScale returns the value that was added to the "price_scale" field in this mutation.
func (m *ProductSpuMutation) AddedPriceScale() (r int8, exists bool) {
	v := m.addprice_scale
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriceScale resets all changes to the "price_scale" field.
func (m *ProductSpuMutation) ResetPriceScale() {
	m.price_scale = nil
	m.addprice_scale = nil
}

// SetMarketPriceFee sets the "market_price_fee" field.
func (m *ProductSpuMutation) SetMarketPriceFee(i int64) {
	m.market_price_fee = &i
	m.addmarket_price_fee = nil
}

// MarketPriceFee returns the value of the "market_price_fee" field in the mutation.
func (m *ProductSpuMutation) MarketPriceFee() (r int64, exists bool) {
	v := m.market_price_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldMarketPriceFee returns the old "market_price_fee" field's value of the ProductSpu entity.
// If the ProductSpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpuMutation) OldMarketPriceFee(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMarketPriceFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMarketPriceFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMarketPriceFee: %w", err)
	}
	return oldValue.MarketPriceFee, nil
}

// AddMarketPriceFee adds i to the "market_price_fee" field.
func (m *ProductSpuMutation) AddMarketPriceFee(i int64) {
	if m.addmarket_price_fee != nil {
		*m.addmarket_price_fee += i
	} else {
		m.addmarket_price_fee = &i
	}
}

// AddedMarketPriceFee returns the value that was added to the "market_price_fee" field in this mutation.
func (m *ProductSpuMutation) AddedMarketPriceFee() (r int64, exists bool) {
	v := m.addmarket_price_fee
	if v == nil {
		return
	}
	return *v, true
}

// ResetMarketPriceFee resets all changes to the "market_price_fee" field.
func (m *ProductSpuMutation) ResetMarketPriceFee() {
	m.market_price_fee = nil
	m.addmarket_price_fee = nil
}

// SetMarketPriceScale sets the "market_price_scale" field.
func (m *ProductSpuMutation) SetMarketPriceScale(i int8) {
	m.market_price_scale = &i
	m.addmarket_price_scale = nil
}

// MarketPriceScale returns the value of the "market_price_scale" field in the mutation.
func (m *ProductSpuMutation) MarketPriceScale() (r int8, exists bool) {
	v := m.market_price_scale
	if v == nil {
		return
	}
	return *v, true
}

// OldMarketPriceScale returns the old "market_price_scale" field's value of the ProductSpu entity.
// If the ProductSpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpuMutation) OldMarketPriceScale(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMarketPriceScale is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMarketPriceScale requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMarketPriceScale: %w", err)
	}
	return oldValue.MarketPriceScale, nil
}

// AddMarketPriceScale adds i to the "market_price_scale" field.
func (m *ProductSpuMutation) AddMarketPriceScale(i int8) {
	if m.addmarket_price_scale != nil {
		*m.addmarket_price_scale += i
	} else {
		m.addmarket_price_scale = &i
	}
}

// AddedMarketPriceScale returns the value that was added to the "market_price_scale" field in this mutation.
func (m *ProductSpuMutation) AddedMarketPriceScale() (r int8, exists bool) {
	v := m.addmarket_price_scale
	if v == nil {
		return
	}
	return *v, true
}

// ResetMarketPriceScale resets all changes to the "market_price_scale" field.
func (m *ProductSpuMutation) ResetMarketPriceScale() {
	m.market_price_scale = nil
	m.addmarket_price_scale = nil
}

// SetCreateAt sets the "create_at" field.
func (m *ProductSpuMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *ProductSpuMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the ProductSpu entity.
// If the ProductSpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpuMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *ProductSpuMutation) ResetCreateAt() {
	m.create_at = nil
}

// SetUpdateAt sets the "update_at" field.
func (m *ProductSpuMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *ProductSpuMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the ProductSpu entity.
// If the ProductSpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpuMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *ProductSpuMutation) ResetUpdateAt() {
	m.update_at = nil
}

// SetStatus sets the "status" field.
func (m *ProductSpuMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ProductSpuMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ProductSpu entity.
// If the ProductSpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpuMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *ProductSpuMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ProductSpuMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *ProductSpuMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// Op returns the operation name.
func (m *ProductSpuMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProductSpu).
func (m *ProductSpuMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductSpuMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.brand_id != nil {
		fields = append(fields, productspu.FieldBrandID)
	}
	if m.category_id != nil {
		fields = append(fields, productspu.FieldCategoryID)
	}
	if m.name != nil {
		fields = append(fields, productspu.FieldName)
	}
	if m.desc != nil {
		fields = append(fields, productspu.FieldDesc)
	}
	if m.selling_point != nil {
		fields = append(fields, productspu.FieldSellingPoint)
	}
	if m.unit != nil {
		fields = append(fields, productspu.FieldUnit)
	}
	if m.banner_url != nil {
		fields = append(fields, productspu.FieldBannerURL)
	}
	if m.main_url != nil {
		fields = append(fields, productspu.FieldMainURL)
	}
	if m.price_fee != nil {
		fields = append(fields, productspu.FieldPriceFee)
	}
	if m.price_scale != nil {
		fields = append(fields, productspu.FieldPriceScale)
	}
	if m.market_price_fee != nil {
		fields = append(fields, productspu.FieldMarketPriceFee)
	}
	if m.market_price_scale != nil {
		fields = append(fields, productspu.FieldMarketPriceScale)
	}
	if m.create_at != nil {
		fields = append(fields, productspu.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, productspu.FieldUpdateAt)
	}
	if m.status != nil {
		fields = append(fields, productspu.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductSpuMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productspu.FieldBrandID:
		return m.BrandID()
	case productspu.FieldCategoryID:
		return m.CategoryID()
	case productspu.FieldName:
		return m.Name()
	case productspu.FieldDesc:
		return m.Desc()
	case productspu.FieldSellingPoint:
		return m.SellingPoint()
	case productspu.FieldUnit:
		return m.Unit()
	case productspu.FieldBannerURL:
		return m.BannerURL()
	case productspu.FieldMainURL:
		return m.MainURL()
	case productspu.FieldPriceFee:
		return m.PriceFee()
	case productspu.FieldPriceScale:
		return m.PriceScale()
	case productspu.FieldMarketPriceFee:
		return m.MarketPriceFee()
	case productspu.FieldMarketPriceScale:
		return m.MarketPriceScale()
	case productspu.FieldCreateAt:
		return m.CreateAt()
	case productspu.FieldUpdateAt:
		return m.UpdateAt()
	case productspu.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductSpuMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productspu.FieldBrandID:
		return m.OldBrandID(ctx)
	case productspu.FieldCategoryID:
		return m.OldCategoryID(ctx)
	case productspu.FieldName:
		return m.OldName(ctx)
	case productspu.FieldDesc:
		return m.OldDesc(ctx)
	case productspu.FieldSellingPoint:
		return m.OldSellingPoint(ctx)
	case productspu.FieldUnit:
		return m.OldUnit(ctx)
	case productspu.FieldBannerURL:
		return m.OldBannerURL(ctx)
	case productspu.FieldMainURL:
		return m.OldMainURL(ctx)
	case productspu.FieldPriceFee:
		return m.OldPriceFee(ctx)
	case productspu.FieldPriceScale:
		return m.OldPriceScale(ctx)
	case productspu.FieldMarketPriceFee:
		return m.OldMarketPriceFee(ctx)
	case productspu.FieldMarketPriceScale:
		return m.OldMarketPriceScale(ctx)
	case productspu.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case productspu.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	case productspu.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown ProductSpu field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductSpuMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productspu.FieldBrandID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrandID(v)
		return nil
	case productspu.FieldCategoryID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryID(v)
		return nil
	case productspu.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case productspu.FieldDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case productspu.FieldSellingPoint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSellingPoint(v)
		return nil
	case productspu.FieldUnit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnit(v)
		return nil
	case productspu.FieldBannerURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBannerURL(v)
		return nil
	case productspu.FieldMainURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMainURL(v)
		return nil
	case productspu.FieldPriceFee:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriceFee(v)
		return nil
	case productspu.FieldPriceScale:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriceScale(v)
		return nil
	case productspu.FieldMarketPriceFee:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMarketPriceFee(v)
		return nil
	case productspu.FieldMarketPriceScale:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMarketPriceScale(v)
		return nil
	case productspu.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case productspu.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	case productspu.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown ProductSpu field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductSpuMutation) AddedFields() []string {
	var fields []string
	if m.addbrand_id != nil {
		fields = append(fields, productspu.FieldBrandID)
	}
	if m.addcategory_id != nil {
		fields = append(fields, productspu.FieldCategoryID)
	}
	if m.addprice_fee != nil {
		fields = append(fields, productspu.FieldPriceFee)
	}
	if m.addprice_scale != nil {
		fields = append(fields, productspu.FieldPriceScale)
	}
	if m.addmarket_price_fee != nil {
		fields = append(fields, productspu.FieldMarketPriceFee)
	}
	if m.addmarket_price_scale != nil {
		fields = append(fields, productspu.FieldMarketPriceScale)
	}
	if m.addstatus != nil {
		fields = append(fields, productspu.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductSpuMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case productspu.FieldBrandID:
		return m.AddedBrandID()
	case productspu.FieldCategoryID:
		return m.AddedCategoryID()
	case productspu.FieldPriceFee:
		return m.AddedPriceFee()
	case productspu.FieldPriceScale:
		return m.AddedPriceScale()
	case productspu.FieldMarketPriceFee:
		return m.AddedMarketPriceFee()
	case productspu.FieldMarketPriceScale:
		return m.AddedMarketPriceScale()
	case productspu.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductSpuMutation) AddField(name string, value ent.Value) error {
	switch name {
	case productspu.FieldBrandID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBrandID(v)
		return nil
	case productspu.FieldCategoryID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCategoryID(v)
		return nil
	case productspu.FieldPriceFee:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriceFee(v)
		return nil
	case productspu.FieldPriceScale:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriceScale(v)
		return nil
	case productspu.FieldMarketPriceFee:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMarketPriceFee(v)
		return nil
	case productspu.FieldMarketPriceScale:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMarketPriceScale(v)
		return nil
	case productspu.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown ProductSpu numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductSpuMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductSpuMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductSpuMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProductSpu nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductSpuMutation) ResetField(name string) error {
	switch name {
	case productspu.FieldBrandID:
		m.ResetBrandID()
		return nil
	case productspu.FieldCategoryID:
		m.ResetCategoryID()
		return nil
	case productspu.FieldName:
		m.ResetName()
		return nil
	case productspu.FieldDesc:
		m.ResetDesc()
		return nil
	case productspu.FieldSellingPoint:
		m.ResetSellingPoint()
		return nil
	case productspu.FieldUnit:
		m.ResetUnit()
		return nil
	case productspu.FieldBannerURL:
		m.ResetBannerURL()
		return nil
	case productspu.FieldMainURL:
		m.ResetMainURL()
		return nil
	case productspu.FieldPriceFee:
		m.ResetPriceFee()
		return nil
	case productspu.FieldPriceScale:
		m.ResetPriceScale()
		return nil
	case productspu.FieldMarketPriceFee:
		m.ResetMarketPriceFee()
		return nil
	case productspu.FieldMarketPriceScale:
		m.ResetMarketPriceScale()
		return nil
	case productspu.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case productspu.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	case productspu.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown ProductSpu field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductSpuMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductSpuMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductSpuMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductSpuMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductSpuMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductSpuMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductSpuMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ProductSpu unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductSpuMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ProductSpu edge %s", name)
}

// ProductSpuSkuAttrMapMutation represents an operation that mutates the ProductSpuSkuAttrMap nodes in the graph.
type ProductSpuSkuAttrMapMutation struct {
	config
	op            Op
	typ           string
	id            *int
	create_at     *time.Time
	update_at     *time.Time
	status        *int8
	addstatus     *int8
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ProductSpuSkuAttrMap, error)
	predicates    []predicate.ProductSpuSkuAttrMap
}

var _ ent.Mutation = (*ProductSpuSkuAttrMapMutation)(nil)

// productspuskuattrmapOption allows management of the mutation configuration using functional options.
type productspuskuattrmapOption func(*ProductSpuSkuAttrMapMutation)

// newProductSpuSkuAttrMapMutation creates new mutation for the ProductSpuSkuAttrMap entity.
func newProductSpuSkuAttrMapMutation(c config, op Op, opts ...productspuskuattrmapOption) *ProductSpuSkuAttrMapMutation {
	m := &ProductSpuSkuAttrMapMutation{
		config:        c,
		op:            op,
		typ:           TypeProductSpuSkuAttrMap,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductSpuSkuAttrMapID sets the ID field of the mutation.
func withProductSpuSkuAttrMapID(id int) productspuskuattrmapOption {
	return func(m *ProductSpuSkuAttrMapMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductSpuSkuAttrMap
		)
		m.oldValue = func(ctx context.Context) (*ProductSpuSkuAttrMap, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductSpuSkuAttrMap.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductSpuSkuAttrMap sets the old ProductSpuSkuAttrMap of the mutation.
func withProductSpuSkuAttrMap(node *ProductSpuSkuAttrMap) productspuskuattrmapOption {
	return func(m *ProductSpuSkuAttrMapMutation) {
		m.oldValue = func(context.Context) (*ProductSpuSkuAttrMap, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductSpuSkuAttrMapMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductSpuSkuAttrMapMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *ProductSpuSkuAttrMapMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateAt sets the "create_at" field.
func (m *ProductSpuSkuAttrMapMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *ProductSpuSkuAttrMapMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the ProductSpuSkuAttrMap entity.
// If the ProductSpuSkuAttrMap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpuSkuAttrMapMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *ProductSpuSkuAttrMapMutation) ResetCreateAt() {
	m.create_at = nil
}

// SetUpdateAt sets the "update_at" field.
func (m *ProductSpuSkuAttrMapMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *ProductSpuSkuAttrMapMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the ProductSpuSkuAttrMap entity.
// If the ProductSpuSkuAttrMap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpuSkuAttrMapMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *ProductSpuSkuAttrMapMutation) ResetUpdateAt() {
	m.update_at = nil
}

// SetStatus sets the "status" field.
func (m *ProductSpuSkuAttrMapMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ProductSpuSkuAttrMapMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ProductSpuSkuAttrMap entity.
// If the ProductSpuSkuAttrMap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpuSkuAttrMapMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *ProductSpuSkuAttrMapMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ProductSpuSkuAttrMapMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *ProductSpuSkuAttrMapMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// Op returns the operation name.
func (m *ProductSpuSkuAttrMapMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProductSpuSkuAttrMap).
func (m *ProductSpuSkuAttrMapMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductSpuSkuAttrMapMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_at != nil {
		fields = append(fields, productspuskuattrmap.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, productspuskuattrmap.FieldUpdateAt)
	}
	if m.status != nil {
		fields = append(fields, productspuskuattrmap.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductSpuSkuAttrMapMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productspuskuattrmap.FieldCreateAt:
		return m.CreateAt()
	case productspuskuattrmap.FieldUpdateAt:
		return m.UpdateAt()
	case productspuskuattrmap.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductSpuSkuAttrMapMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productspuskuattrmap.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case productspuskuattrmap.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	case productspuskuattrmap.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown ProductSpuSkuAttrMap field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductSpuSkuAttrMapMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productspuskuattrmap.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case productspuskuattrmap.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	case productspuskuattrmap.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown ProductSpuSkuAttrMap field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductSpuSkuAttrMapMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, productspuskuattrmap.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductSpuSkuAttrMapMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case productspuskuattrmap.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductSpuSkuAttrMapMutation) AddField(name string, value ent.Value) error {
	switch name {
	case productspuskuattrmap.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown ProductSpuSkuAttrMap numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductSpuSkuAttrMapMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductSpuSkuAttrMapMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductSpuSkuAttrMapMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProductSpuSkuAttrMap nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductSpuSkuAttrMapMutation) ResetField(name string) error {
	switch name {
	case productspuskuattrmap.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case productspuskuattrmap.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	case productspuskuattrmap.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown ProductSpuSkuAttrMap field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductSpuSkuAttrMapMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductSpuSkuAttrMapMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductSpuSkuAttrMapMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductSpuSkuAttrMapMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductSpuSkuAttrMapMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductSpuSkuAttrMapMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductSpuSkuAttrMapMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ProductSpuSkuAttrMap unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductSpuSkuAttrMapMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ProductSpuSkuAttrMap edge %s", name)
}

// SkrMemberMutation represents an operation that mutates the SkrMember nodes in the graph.
type SkrMemberMutation struct {
	config
	op            Op
	typ           string
	id            *int
	uid           *int64
	adduid        *int64
	nickname      *string
	avatar        *string
	gender        *int8
	addgender     *int8
	role          *int8
	addrole       *int8
	create_at     *time.Time
	update_at     *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*SkrMember, error)
	predicates    []predicate.SkrMember
}

var _ ent.Mutation = (*SkrMemberMutation)(nil)

// skrmemberOption allows management of the mutation configuration using functional options.
type skrmemberOption func(*SkrMemberMutation)

// newSkrMemberMutation creates new mutation for the SkrMember entity.
func newSkrMemberMutation(c config, op Op, opts ...skrmemberOption) *SkrMemberMutation {
	m := &SkrMemberMutation{
		config:        c,
		op:            op,
		typ:           TypeSkrMember,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSkrMemberID sets the ID field of the mutation.
func withSkrMemberID(id int) skrmemberOption {
	return func(m *SkrMemberMutation) {
		var (
			err   error
			once  sync.Once
			value *SkrMember
		)
		m.oldValue = func(ctx context.Context) (*SkrMember, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SkrMember.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSkrMember sets the old SkrMember of the mutation.
func withSkrMember(node *SkrMember) skrmemberOption {
	return func(m *SkrMemberMutation) {
		m.oldValue = func(context.Context) (*SkrMember, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SkrMemberMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SkrMemberMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *SkrMemberMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUID sets the "uid" field.
func (m *SkrMemberMutation) SetUID(i int64) {
	m.uid = &i
	m.adduid = nil
}

// UID returns the value of the "uid" field in the mutation.
func (m *SkrMemberMutation) UID() (r int64, exists bool) {
	v := m.uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUID returns the old "uid" field's value of the SkrMember entity.
// If the SkrMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkrMemberMutation) OldUID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUID: %w", err)
	}
	return oldValue.UID, nil
}

// AddUID adds i to the "uid" field.
func (m *SkrMemberMutation) AddUID(i int64) {
	if m.adduid != nil {
		*m.adduid += i
	} else {
		m.adduid = &i
	}
}

// AddedUID returns the value that was added to the "uid" field in this mutation.
func (m *SkrMemberMutation) AddedUID() (r int64, exists bool) {
	v := m.adduid
	if v == nil {
		return
	}
	return *v, true
}

// ResetUID resets all changes to the "uid" field.
func (m *SkrMemberMutation) ResetUID() {
	m.uid = nil
	m.adduid = nil
}

// SetNickname sets the "nickname" field.
func (m *SkrMemberMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *SkrMemberMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the SkrMember entity.
// If the SkrMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkrMemberMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ResetNickname resets all changes to the "nickname" field.
func (m *SkrMemberMutation) ResetNickname() {
	m.nickname = nil
}

// SetAvatar sets the "avatar" field.
func (m *SkrMemberMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *SkrMemberMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the SkrMember entity.
// If the SkrMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkrMemberMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *SkrMemberMutation) ResetAvatar() {
	m.avatar = nil
}

// SetGender sets the "gender" field.
func (m *SkrMemberMutation) SetGender(i int8) {
	m.gender = &i
	m.addgender = nil
}

// Gender returns the value of the "gender" field in the mutation.
func (m *SkrMemberMutation) Gender() (r int8, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the SkrMember entity.
// If the SkrMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkrMemberMutation) OldGender(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// AddGender adds i to the "gender" field.
func (m *SkrMemberMutation) AddGender(i int8) {
	if m.addgender != nil {
		*m.addgender += i
	} else {
		m.addgender = &i
	}
}

// AddedGender returns the value that was added to the "gender" field in this mutation.
func (m *SkrMemberMutation) AddedGender() (r int8, exists bool) {
	v := m.addgender
	if v == nil {
		return
	}
	return *v, true
}

// ResetGender resets all changes to the "gender" field.
func (m *SkrMemberMutation) ResetGender() {
	m.gender = nil
	m.addgender = nil
}

// SetRole sets the "role" field.
func (m *SkrMemberMutation) SetRole(i int8) {
	m.role = &i
	m.addrole = nil
}

// Role returns the value of the "role" field in the mutation.
func (m *SkrMemberMutation) Role() (r int8, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the SkrMember entity.
// If the SkrMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkrMemberMutation) OldRole(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// AddRole adds i to the "role" field.
func (m *SkrMemberMutation) AddRole(i int8) {
	if m.addrole != nil {
		*m.addrole += i
	} else {
		m.addrole = &i
	}
}

// AddedRole returns the value that was added to the "role" field in this mutation.
func (m *SkrMemberMutation) AddedRole() (r int8, exists bool) {
	v := m.addrole
	if v == nil {
		return
	}
	return *v, true
}

// ResetRole resets all changes to the "role" field.
func (m *SkrMemberMutation) ResetRole() {
	m.role = nil
	m.addrole = nil
}

// SetCreateAt sets the "create_at" field.
func (m *SkrMemberMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *SkrMemberMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the SkrMember entity.
// If the SkrMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkrMemberMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *SkrMemberMutation) ResetCreateAt() {
	m.create_at = nil
}

// SetUpdateAt sets the "update_at" field.
func (m *SkrMemberMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *SkrMemberMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the SkrMember entity.
// If the SkrMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkrMemberMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *SkrMemberMutation) ResetUpdateAt() {
	m.update_at = nil
}

// Op returns the operation name.
func (m *SkrMemberMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SkrMember).
func (m *SkrMemberMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SkrMemberMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.uid != nil {
		fields = append(fields, skrmember.FieldUID)
	}
	if m.nickname != nil {
		fields = append(fields, skrmember.FieldNickname)
	}
	if m.avatar != nil {
		fields = append(fields, skrmember.FieldAvatar)
	}
	if m.gender != nil {
		fields = append(fields, skrmember.FieldGender)
	}
	if m.role != nil {
		fields = append(fields, skrmember.FieldRole)
	}
	if m.create_at != nil {
		fields = append(fields, skrmember.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, skrmember.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SkrMemberMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case skrmember.FieldUID:
		return m.UID()
	case skrmember.FieldNickname:
		return m.Nickname()
	case skrmember.FieldAvatar:
		return m.Avatar()
	case skrmember.FieldGender:
		return m.Gender()
	case skrmember.FieldRole:
		return m.Role()
	case skrmember.FieldCreateAt:
		return m.CreateAt()
	case skrmember.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SkrMemberMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case skrmember.FieldUID:
		return m.OldUID(ctx)
	case skrmember.FieldNickname:
		return m.OldNickname(ctx)
	case skrmember.FieldAvatar:
		return m.OldAvatar(ctx)
	case skrmember.FieldGender:
		return m.OldGender(ctx)
	case skrmember.FieldRole:
		return m.OldRole(ctx)
	case skrmember.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case skrmember.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown SkrMember field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SkrMemberMutation) SetField(name string, value ent.Value) error {
	switch name {
	case skrmember.FieldUID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	case skrmember.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case skrmember.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case skrmember.FieldGender:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case skrmember.FieldRole:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case skrmember.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case skrmember.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown SkrMember field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SkrMemberMutation) AddedFields() []string {
	var fields []string
	if m.adduid != nil {
		fields = append(fields, skrmember.FieldUID)
	}
	if m.addgender != nil {
		fields = append(fields, skrmember.FieldGender)
	}
	if m.addrole != nil {
		fields = append(fields, skrmember.FieldRole)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SkrMemberMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case skrmember.FieldUID:
		return m.AddedUID()
	case skrmember.FieldGender:
		return m.AddedGender()
	case skrmember.FieldRole:
		return m.AddedRole()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SkrMemberMutation) AddField(name string, value ent.Value) error {
	switch name {
	case skrmember.FieldUID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUID(v)
		return nil
	case skrmember.FieldGender:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGender(v)
		return nil
	case skrmember.FieldRole:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRole(v)
		return nil
	}
	return fmt.Errorf("unknown SkrMember numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SkrMemberMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SkrMemberMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SkrMemberMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SkrMember nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SkrMemberMutation) ResetField(name string) error {
	switch name {
	case skrmember.FieldUID:
		m.ResetUID()
		return nil
	case skrmember.FieldNickname:
		m.ResetNickname()
		return nil
	case skrmember.FieldAvatar:
		m.ResetAvatar()
		return nil
	case skrmember.FieldGender:
		m.ResetGender()
		return nil
	case skrmember.FieldRole:
		m.ResetRole()
		return nil
	case skrmember.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case skrmember.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown SkrMember field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SkrMemberMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SkrMemberMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SkrMemberMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SkrMemberMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SkrMemberMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SkrMemberMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SkrMemberMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SkrMember unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SkrMemberMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SkrMember edge %s", name)
}

// StaffInfoMutation represents an operation that mutates the StaffInfo nodes in the graph.
type StaffInfoMutation struct {
	config
	op            Op
	typ           string
	id            *int
	uid           *int64
	adduid        *int64
	email         *string
	phone         *string
	password      *string
	name          *string
	avatar        *string
	gender        *int8
	addgender     *int8
	create_at     *time.Time
	update_at     *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*StaffInfo, error)
	predicates    []predicate.StaffInfo
}

var _ ent.Mutation = (*StaffInfoMutation)(nil)

// staffinfoOption allows management of the mutation configuration using functional options.
type staffinfoOption func(*StaffInfoMutation)

// newStaffInfoMutation creates new mutation for the StaffInfo entity.
func newStaffInfoMutation(c config, op Op, opts ...staffinfoOption) *StaffInfoMutation {
	m := &StaffInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeStaffInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStaffInfoID sets the ID field of the mutation.
func withStaffInfoID(id int) staffinfoOption {
	return func(m *StaffInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *StaffInfo
		)
		m.oldValue = func(ctx context.Context) (*StaffInfo, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StaffInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStaffInfo sets the old StaffInfo of the mutation.
func withStaffInfo(node *StaffInfo) staffinfoOption {
	return func(m *StaffInfoMutation) {
		m.oldValue = func(context.Context) (*StaffInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StaffInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StaffInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *StaffInfoMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUID sets the "uid" field.
func (m *StaffInfoMutation) SetUID(i int64) {
	m.uid = &i
	m.adduid = nil
}

// UID returns the value of the "uid" field in the mutation.
func (m *StaffInfoMutation) UID() (r int64, exists bool) {
	v := m.uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUID returns the old "uid" field's value of the StaffInfo entity.
// If the StaffInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffInfoMutation) OldUID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUID: %w", err)
	}
	return oldValue.UID, nil
}

// AddUID adds i to the "uid" field.
func (m *StaffInfoMutation) AddUID(i int64) {
	if m.adduid != nil {
		*m.adduid += i
	} else {
		m.adduid = &i
	}
}

// AddedUID returns the value that was added to the "uid" field in this mutation.
func (m *StaffInfoMutation) AddedUID() (r int64, exists bool) {
	v := m.adduid
	if v == nil {
		return
	}
	return *v, true
}

// ResetUID resets all changes to the "uid" field.
func (m *StaffInfoMutation) ResetUID() {
	m.uid = nil
	m.adduid = nil
}

// SetEmail sets the "email" field.
func (m *StaffInfoMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *StaffInfoMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the StaffInfo entity.
// If the StaffInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffInfoMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *StaffInfoMutation) ResetEmail() {
	m.email = nil
}

// SetPhone sets the "phone" field.
func (m *StaffInfoMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *StaffInfoMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the StaffInfo entity.
// If the StaffInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffInfoMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *StaffInfoMutation) ResetPhone() {
	m.phone = nil
}

// SetPassword sets the "password" field.
func (m *StaffInfoMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *StaffInfoMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the StaffInfo entity.
// If the StaffInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffInfoMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *StaffInfoMutation) ResetPassword() {
	m.password = nil
}

// SetName sets the "name" field.
func (m *StaffInfoMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *StaffInfoMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the StaffInfo entity.
// If the StaffInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffInfoMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *StaffInfoMutation) ResetName() {
	m.name = nil
}

// SetAvatar sets the "avatar" field.
func (m *StaffInfoMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *StaffInfoMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the StaffInfo entity.
// If the StaffInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffInfoMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *StaffInfoMutation) ResetAvatar() {
	m.avatar = nil
}

// SetGender sets the "gender" field.
func (m *StaffInfoMutation) SetGender(i int8) {
	m.gender = &i
	m.addgender = nil
}

// Gender returns the value of the "gender" field in the mutation.
func (m *StaffInfoMutation) Gender() (r int8, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the StaffInfo entity.
// If the StaffInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffInfoMutation) OldGender(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// AddGender adds i to the "gender" field.
func (m *StaffInfoMutation) AddGender(i int8) {
	if m.addgender != nil {
		*m.addgender += i
	} else {
		m.addgender = &i
	}
}

// AddedGender returns the value that was added to the "gender" field in this mutation.
func (m *StaffInfoMutation) AddedGender() (r int8, exists bool) {
	v := m.addgender
	if v == nil {
		return
	}
	return *v, true
}

// ResetGender resets all changes to the "gender" field.
func (m *StaffInfoMutation) ResetGender() {
	m.gender = nil
	m.addgender = nil
}

// SetCreateAt sets the "create_at" field.
func (m *StaffInfoMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *StaffInfoMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the StaffInfo entity.
// If the StaffInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffInfoMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *StaffInfoMutation) ResetCreateAt() {
	m.create_at = nil
}

// SetUpdateAt sets the "update_at" field.
func (m *StaffInfoMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *StaffInfoMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the StaffInfo entity.
// If the StaffInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffInfoMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *StaffInfoMutation) ResetUpdateAt() {
	m.update_at = nil
}

// Op returns the operation name.
func (m *StaffInfoMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (StaffInfo).
func (m *StaffInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StaffInfoMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.uid != nil {
		fields = append(fields, staffinfo.FieldUID)
	}
	if m.email != nil {
		fields = append(fields, staffinfo.FieldEmail)
	}
	if m.phone != nil {
		fields = append(fields, staffinfo.FieldPhone)
	}
	if m.password != nil {
		fields = append(fields, staffinfo.FieldPassword)
	}
	if m.name != nil {
		fields = append(fields, staffinfo.FieldName)
	}
	if m.avatar != nil {
		fields = append(fields, staffinfo.FieldAvatar)
	}
	if m.gender != nil {
		fields = append(fields, staffinfo.FieldGender)
	}
	if m.create_at != nil {
		fields = append(fields, staffinfo.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, staffinfo.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StaffInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case staffinfo.FieldUID:
		return m.UID()
	case staffinfo.FieldEmail:
		return m.Email()
	case staffinfo.FieldPhone:
		return m.Phone()
	case staffinfo.FieldPassword:
		return m.Password()
	case staffinfo.FieldName:
		return m.Name()
	case staffinfo.FieldAvatar:
		return m.Avatar()
	case staffinfo.FieldGender:
		return m.Gender()
	case staffinfo.FieldCreateAt:
		return m.CreateAt()
	case staffinfo.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StaffInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case staffinfo.FieldUID:
		return m.OldUID(ctx)
	case staffinfo.FieldEmail:
		return m.OldEmail(ctx)
	case staffinfo.FieldPhone:
		return m.OldPhone(ctx)
	case staffinfo.FieldPassword:
		return m.OldPassword(ctx)
	case staffinfo.FieldName:
		return m.OldName(ctx)
	case staffinfo.FieldAvatar:
		return m.OldAvatar(ctx)
	case staffinfo.FieldGender:
		return m.OldGender(ctx)
	case staffinfo.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case staffinfo.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown StaffInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StaffInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case staffinfo.FieldUID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	case staffinfo.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case staffinfo.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case staffinfo.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case staffinfo.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case staffinfo.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case staffinfo.FieldGender:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case staffinfo.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case staffinfo.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown StaffInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StaffInfoMutation) AddedFields() []string {
	var fields []string
	if m.adduid != nil {
		fields = append(fields, staffinfo.FieldUID)
	}
	if m.addgender != nil {
		fields = append(fields, staffinfo.FieldGender)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StaffInfoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case staffinfo.FieldUID:
		return m.AddedUID()
	case staffinfo.FieldGender:
		return m.AddedGender()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StaffInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case staffinfo.FieldUID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUID(v)
		return nil
	case staffinfo.FieldGender:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGender(v)
		return nil
	}
	return fmt.Errorf("unknown StaffInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StaffInfoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StaffInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StaffInfoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown StaffInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StaffInfoMutation) ResetField(name string) error {
	switch name {
	case staffinfo.FieldUID:
		m.ResetUID()
		return nil
	case staffinfo.FieldEmail:
		m.ResetEmail()
		return nil
	case staffinfo.FieldPhone:
		m.ResetPhone()
		return nil
	case staffinfo.FieldPassword:
		m.ResetPassword()
		return nil
	case staffinfo.FieldName:
		m.ResetName()
		return nil
	case staffinfo.FieldAvatar:
		m.ResetAvatar()
		return nil
	case staffinfo.FieldGender:
		m.ResetGender()
		return nil
	case staffinfo.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case staffinfo.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown StaffInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StaffInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StaffInfoMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StaffInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StaffInfoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StaffInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StaffInfoMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StaffInfoMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown StaffInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StaffInfoMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown StaffInfo edge %s", name)
}
